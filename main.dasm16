; DCPU-16 KERNAL and BASIC based on the Commodore 64 KERNAL
; by Nick Bensema


; I'll petition Notch to make these mnemonics standard
; once I have all my ducks in a row.
MACRO JMP = SET PC, %0
MACRO JMP_IND = SET PC, [%0]
MACRO RTS = SET PC, POP

JMP_IND ROMFFFC   ; RESET vector

; config.dasm16 is mostly useful for setting up
; test parameters.
.INCLUDE "config.dasm16"

; -- KERNAL --
;----------------
;  KERNAL MAIN
;----------------

; I'm leaving the last 1/16 of memory for machine language
; programs, I guess.
.DEFINE BASICMEMEND, 0xEFFF

; PETSCII constants
.DEFINE CBM_STOP, 0x03
.DEFINE CBM_RETURN, 0x0D
.DEFINE CBM_DELETE, 0x14
.DEFINE CBM_INSERT, 0x94
.DEFINE CBM_UP, 0x91
.DEFINE CBM_DOWN, 0x11
.DEFINE CBM_LEFT, 0x9D
.DEFINE CBM_RIGHT, 0x1D
.DEFINE CBM_HOME, 0x13
.DEFINE CBM_CLR, 0x93
.DEFINE CBM_SPACE, 0x20
.DEFINE CBM_QUOTE, 0x22
.DEFINE CBM_COMMA, 0x2C
.DEFINE CBM_COLON, 0x3A
.DEFINE CBM_RUN, 0x83


:ROMA000    DAT ROME394     ; Vector for starting BASIC
:ROMA002    DAT ROME37B

; C64 RAM equivalents
;

;
;  Main BASIC interpreter
;
;  requires math.dasm16
;
;  TODO: add list of kernal dependencies.
;
;
:RAM03  
:ADRAY1 DAT BLANK
:RAM05  
:ADRAY2 DAT BLANK
:RAM07
:CHARAC DAT BLANK
:RAM08
:ENDCHR DAT BLANK
:RAM09  ; Column position of cursor before last TAB or SPC
:TRMPOS DAT BLANK
:RAM0B
:COUNT  DAT BLANK
:RAM0C
:DIMFLG DAT BLANK
; todo: standardize the value stored here.
:RAM0D
:VALTYP DAT BLANK
:RAM0E
:INTFLG DAT BLANK
:RAM0F  ; Flag for LIST, Garbage Collection, and Program Tokenization
:GARBFL DAT 0
:RAM10  ; Flag: Subscript Reference to an Array or User-Defined Function Call
:SUBFLG DAT 0
:RAM11  ; Flag: is data input to GET, READ, or INPUT?
:INPFLG DAT BLANK
.DEFINE INF_READ, 0x98
.DEFINE INF_GET, 0x40
.DEFINE INF_INPUT, 0x0
:RAM12
:TANSGN DAT BLANK
:RAM13 ; Current logical file number
:CHANNL DAT 0
:RAM14  ; Line Number for LIST/GOTO, memory address for PEEK/POKE/SYS
:LINNUM DAT 0
:RAM16  ; Pointer to the next available space in the temporary string stack
:TEMPPT DAT TEMPST
:RAM17  ; Pointer to the address of the last string in the temporary string stack
:LASTPT DAT 0
:RAM19 ; Descriptor stack for temporary strings
:TEMPST
    .FILL BLANK, 10
:TEMPSTEND
:RAM22
:INDEX  DAT BLANK, BLANK
; Pointer to the start of BASIC program text
:RAM2B  
:TXTTAB DAT BASICMEM+1

; Pointer to the variable storage area
:RAM2D
:VARTAB DAT 0
; Pointer to the start of the array storage area
:RAM2F
:ARYTAB DAT 0
; Pointer to the start of free RAM
:RAM31
:STREND DAT 0
:RAM33
:FREETOP    DAT 0
; Temporary Pointer for Strings
:RAM35
:FRESPC DAT 0
:RAM37 ; Pointer to highest address used by basic
:MEMSIZ DAT 0
;Current basic line number (>0xF00 in immediate mode)
:RAM39
:CURLIN DAT 0
:RAM3B
:OLDLIN DAT 0
:RAM3D
:OLDTXT DAT 0
:RAM3F
:DATLIN DAT 0
:RAM41
:DATPTR DAT 0
:RAM43
:INPPTR DAT 0
:RAM45  
:VARNAM DAT 0, 0
:RAM47
:VARPNT DAT 0
:RAM49
:FORPNT DAT 0
:RAM4B
:OPPTR  DAT 0
:RAM4D
:OPMASK DAT 0
.DEFINE OPM_LT, 1
.DEFINE OPM_EQ, 2
.DEFINE OPM_GT, 4
:RAM4E
:DEFPNT DAT 0
;temporary pointer to the current string descriptor
:RAM50
:DSCPNT DAT 0
:DSCLEN
:RAM53  DAT 0
:RAM55  DAT 0
; Parameters for memory copying and manipulation
:RAM58
:HIGHDS DAT 0
:RAM5F
:LOWTR  DAT 0
:RAM5A
:HIGHTR DAT 0

:FBUFPT ; Series Evaluation Pointer
:RAM71  DAT 0

.INCLUDE chrget.dasm16

; debugging routine for garbage collector
;.MACRO GARBDEBUG(F)
            ;SET C, [GARBDISPLAY] 
            ;SET [C], 0x7000
            ;ADD [C], F
            ;ADD [GARBDISPLAY], 1 
;.ENDMACRO
:GARBDISPLAY  DAT SCREENMEM+64

:USRPOK
:RAM0310    JMP 1234
.DEFINE RAM0311, USRPOK+1
.DEFINE USRADD, USRPOK+1

; ************* BASIC ROM ************


; some special tokens
.DEFINE BASIC_FOR_TOKEN, 0x81
.DEFINE BASIC_TO_TOKEN, 0xA4
.DEFINE BASIC_STEP_TOKEN, 0xA9
.DEFINE BASIC_DATA_TOKEN, 0x83
.DEFINE BASIC_GOSUB_TOKEN, 0x8D
.DEFINE BASIC_REM_TOKEN, 0x8F
.DEFINE BASIC_PRINT_TOKEN, 0x99
.DEFINE BASIC_GOTO_TOKEN, 0x89
.DEFINE BASIC_THEN_TOKEN, 0xA7
.DEFINE BASIC_TAB_TOKEN, 0xA3
.DEFINE BASIC_SPC_TOKEN, 0xA6
.DEFINE BASIC_FN_TOKEN, 0xA5
.DEFINE BASIC_NOT_TOKEN, 0xA8
.DEFINE BASIC_EQ_TOKEN, 0xB2
.DEFINE BASIC_GT_TOKEN, 0xB1
.DEFINE BASIC_LEFT_TOKEN, 0xC8
.DEFINE BASIC_SGN_TOKEN, 0xB4
.DEFINE BASIC_MINUS_TOKEN, 0xAB
.DEFINE BASIC_PLUS_TOKEN, 0xAA



; address table for commands
; (In original, address minus 1 used because
;  the 6502 added 1 to the PC after an RTS)

:TOKEN_ROUTINES
:ROMA00C
            DAT STMT_END
            DAT STMT_FOR
            DAT STMT_NEXT
            DAT STMT_DATA
            DAT STMT_INPUTN
            DAT STMT_INPUT 
            DAT STMT_DIM 
            DAT STMT_READ  
            DAT STMT_LET   
            DAT STMT_GOTO  
            DAT STMT_RUN   
            DAT STMT_IF
            DAT STMT_RESTORE
            DAT STMT_GOSUB 
            DAT STMT_RETURN
            DAT STMT_REM   
            DAT STMT_STOP  
            DAT STMT_ON
            DAT STMT_WAIT
            DAT STMT_LOAD
            DAT STMT_SAVE
            DAT STMT_VERIFY
            DAT STMT_DEF
            DAT STMT_POKE
            DAT STMT_PRINTN
            DAT STMT_PRINT
            DAT STMT_CONT
            DAT STMT_LIST
            DAT STMT_CLR
            DAT STMT_CMD
            DAT 0xE129 ; sys
            DAT 0xE1BD ; open
            DAT 0xE1C6 ; close
            DAT STMT_GET
            DAT STMT_NEW
:FUNCTION_ROUTINES 
            DAT SGNFUNC ; sgn
            DAT INT     ; int
            DAT ROMBC58 ; abs
            DAT 0x0310  ; usr
            DAT ROMB37D  ; fre
            DAT ROMB39E  ; pos
            DAT SQR
            DAT RND
            DAT LOG
            DAT EXP
            DAT COS
            DAT SIN
            DAT TAN
            DAT ATN  ; atn
            DAT PEEKFUNC  ; peek
            DAT ROMB77C  ; len
            DAT STRD
            DAT VAL
            DAT ASCN
            DAT CHRD
            DAT LEFTD
            DAT RIGHTD
            DAT MIDD

; indexing offset
.DEFINE FUNCTION_VECTOR, FUNCTION_ROUTINES-BASIC_SGN_TOKEN


; priority and address table
; for operators

:TBL_OP   
        DAT 0x79
        DAT FADDT   ; plus
        DAT 0x79
        DAT FSUBT   ; minus
        DAT 0x7B
        DAT FMULTT  ; multiply
        DAT 0x7B
        DAT FDIVT   ; divide
        DAT 0x7F
        DAT FPWRT   ; power
        DAT 0x50
        DAT ANDOP   ; AND
        DAT 0x46
        DAT OROP   ; OR
:TBL_OP_NEG
        DAT 0x7D
        DAT NEGOP   ; negative
:TBL_OP_NOT
        DAT 0x5A
        DAT NOTOP   ; NOT
:TBL_OP_COMPARE
        DAT 0x64
        DAT RELOPS   ; greater / equal / less


; table of commands
; each ended with a +0x80

:TOKEN_NAMES
:ROMA09E   
        DAT 0x45,0x4E,0xC4   ; end
        DAT 0x46,0x4F,0xD2   ; for
        DAT 0x4E,0x45,0x58,0xD4   ; next
        DAT 0x44,0x41,0x54,0xC1   ; data
        DAT 0x49,0x4E,0x50,0x55,0x54,0xA3   ; input#
        DAT 0x49,0x4E,0x50,0x55,0xD4   ; input
        DAT 0x44,0x49,0xCD   ; dim
        DAT 0x52,0x45,0x41,0xC4   ; read
        DAT 0x4C,0x45,0xD4   ; let
        DAT 0x47,0x4F,0x54,0xCF   ; goto
        DAT 0x52,0x55,0xCE   ; run
        DAT 0x49,0xC6   ; if
        DAT 0x52,0x45,0x53,0x54,0x4F,0x52,0xC5   ; restore
        DAT 0x47,0x4F,0x53,0x55,0xC2   ; gosub
        DAT 0x52,0x45,0x54,0x55,0x52,0xCE   ; return
        DAT 0x52,0x45,0xCD   ; rem
        DAT 0x53,0x54,0x4F,0xD0   ; stop
        DAT 0x4F,0xCE   ; on
        DAT 0x57,0x41,0x49,0xD4   ; wait
        DAT 0x4C,0x4F,0x41,0xC4   ; load
        DAT 0x53,0x41,0x56,0xC5   ; save
        DAT 0x56,0x45,0x52,0x49,0x46,0xD9   ; verify
        DAT 0x44,0x45,0xC6   ; def
        DAT 0x50,0x4F,0x4B,0xC5   ; poke
        DAT 0x50,0x52,0x49,0x4E,0x54,0xA3   ; print#
        DAT 0x50,0x52,0x49,0x4E,0xD4   ; print
        DAT 0x43,0x4F,0x4E,0xD4   ; cont
        DAT 0x4C,0x49,0x53,0xD4   ; list
        DAT 0x43,0x4C,0xD2   ; clr
        DAT 0x43,0x4D,0xC4   ; cmd
        DAT 0x53,0x59,0xD3   ; sys
        DAT 0x4F,0x50,0x45,0xCE   ; open
        DAT 0x43,0x4C,0x4F,0x53,0xC5   ; close
        DAT 0x47,0x45,0xD4   ; get
        DAT 0x4E,0x45,0xD7   ; new

        DAT 0x54,0x41,0x42,0xA8   ; tab(
        DAT 0x54,0xCF   ; to
        DAT 0x46,0xCE   ; fn
        DAT 0x53,0x50,0x43,0xA8   ; spc(
        DAT 0x54,0x48,0x45,0xCE   ; then
        DAT 0x4E,0x4F,0xD4   ; not
        DAT 0x53,0x54,0x45,0xD0   ; step
        DAT 0xAB   ; plus
        DAT 0xAD   ; minus
        DAT 0xAA   ; multiply
        DAT 0xAF   ; divide
        DAT 0xDE   ; power
        DAT 0x41,0x4E,0xC4   ; and
        DAT 0x4F,0xD2   ; or
        DAT 0xBE   ; greater
        DAT 0xBD   ; equal
        DAT 0xBC   ; less
        DAT 0x53,0x47,0xCE   ; sgn
        DAT 0x49,0x4E,0xD4   ; int
        DAT 0x41,0x42,0xD3   ; abs
        DAT 0x55,0x53,0xD2   ; usr
        DAT 0x46,0x52,0xC5   ; fre
        DAT 0x50,0x4F,0xD3   ; pos
        DAT 0x53,0x51,0xD2   ; sqr
        DAT 0x52,0x4E,0xC4   ; rnd
        DAT 0x4C,0x4F,0xC7   ; log
        DAT 0x45,0x58,0xD0   ; exp
        DAT 0x43,0x4F,0xD3   ; cos
        DAT 0x53,0x49,0xCE   ; sin
        DAT 0x54,0x41,0xCE   ; tan
        DAT 0x41,0x54,0xCE   ; atn
        DAT 0x50,0x45,0x45,0xCB   ; peek
        DAT 0x4C,0x45,0xCE   ; len
        DAT 0x53,0x54,0x52,0xA4   ; str$
        DAT 0x56,0x41,0xCC   ; val
        DAT 0x41,0x53,0xC3   ; asc
        DAT 0x43,0x48,0x52,0xA4   ; chr$
        DAT 0x4C,0x45,0x46,0x54,0xA4   ; left$
        DAT 0x52,0x49,0x47,0x48,0x54,0xA4   ; right$
        DAT 0x4D,0x49,0x44,0xA4   ; mid$

; other commands

        DAT 0x47,0xCF   ; go
        DAT 0x00    ; end of list


; table of errors messages
; each ended with a +0x80

:ERR01 ;TOO MANY FILES
   DAT 0x54,0x4F,0x4F
   DAT 0x20,0x4D,0x41,0x4E,0x59
   DAT 0x20,0x46,0x49,0x4C,0x45,0xD3
:ERR02 ;FILE OPEN
   DAT 0x46,0x49,0x4C,0x45
   DAT 0x20,0x4F,0x50,0x45,0xCE
:ERR03 ;FILE NOT OPEN
   DAT 0x46,0x49,0x4C,0x45
   DAT 0x20,0x4E,0x4F,0x54
   DAT 0x20,0x4F,0x50,0x45,0xCE
:ERR04 ;FILE NOT FOUND
   DAT 0x46,0x49,0x4C,0x45
   DAT 0x20,0x4E,0x4F,0x54
   DAT 0x20,0x46,0x4F,0x55,0x4E,0xC4
:ERR05 ;DEVICE NOT PRESENT
   DAT 0x44,0x45,0x56,0x49,0x43,0x45
   DAT 0x20,0x4E,0x4F,0x54
   DAT 0x20,0x50,0x52,0x45,0x53,0x45,0x4E,0xD4
:ERR06 ;NOT INPUT FILE
   DAT 0x4E,0x4F,0x54
   DAT 0x20,0x49,0x4E,0x50,0x55,0x54
   DAT 0x20,0x46,0x49,0x4C,0xC5
:ERR07 ;NOT OUTPUT FILE
   DAT 0x4E,0x4F,0x54
   DAT 0x20,0x4F,0x55,0x54,0x50,0x55,0x54
   DAT 0x20,0x46,0x49,0x4C,0xC5
:ERR08 ;MISSING FILE NAME
   DAT 0x4D,0x49,0x53,0x53,0x49,0x4E,0x47
   DAT 0x20,0x46,0x49,0x4C,0x45
   DAT 0x20,0x4E,0x41,0x4D,0xC5
:ERR09 ;ILLEGAL DEVICE NUMBER
   DAT 0x49,0x4C,0x4C,0x45,0x47,0x41,0x4C
   DAT 0x20,0x44,0x45,0x56,0x49,0x43,0x45
   DAT 0x20,0x4E,0x55,0x4D,0x42,0x45,0xD2
:ERR0A ;NEXT WITHOUT FOR
   DAT 0x4E,0x45,0x58,0x54
   DAT 0x20,0x57,0x49,0x54,0x48,0x4F,0x55,0x54
   DAT 0x20,0x46,0x4F,0xD2
:ERR0B ;SYNTAX
   DAT 0x53,0x59,0x4E,0x54,0x41,0xD8
:ERR0C ;RETURN WITHOUT GOSUB
   DAT 0x52,0x45,0x54,0x55,0x52,0x4E
   DAT 0x20,0x57,0x49,0x54,0x48,0x4F,0x55,0x54
   DAT 0x20,0x47,0x4F,0x53,0x55,0xC2
:ERR0D ;OUT OF DATA
   DAT 0x4F,0x55,0x54
   DAT 0x20,0x4F,0x46
   DAT 0x20,0x44,0x41,0x54,0xC1
:ERR0E ;ILLEGAL QUANTITY
   DAT 0x49,0x4C,0x4C,0x45,0x47,0x41,0x4C
   DAT 0x20,0x51,0x55,0x41,0x4E,0x54,0x49,0x54,0xD9
:ERR0F ;OVERFLOW
   DAT 0x4F,0x56,0x45,0x52,0x46,0x4C,0x4F,0xD7
:ERR10 ;OUT OF MEMORY
   DAT 0x4F,0x55,0x54
   DAT 0x20,0x4F,0x46
   DAT 0x20,0x4D,0x45,0x4D,0x4F,0x52,0xD9
:ERR11 ;UNDEF'D STATEMENT
   DAT 0x55,0x4E,0x44,0x45,0x46,0x27,0x44
   DAT 0x20,0x53,0x54,0x41,0x54,0x45,0x4D,0x45,0x4E,0xD4
:ERR12 ;BAD SUBSCRIPT
   DAT 0x42,0x41,0x44
   DAT 0x20,0x53,0x55,0x42,0x53,0x43,0x52,0x49,0x50,0xD4
:ERR13 ;REDIM'D ARRAY
   DAT 0x52,0x45,0x44,0x49,0x4D,0x27,0x44
   DAT 0x20,0x41,0x52,0x52,0x41,0xD9
:ERR14 ;DIVIDION BY ZERO
   DAT 0x44,0x49,0x56,0x49,0x53,0x49,0x4F,0x4E
   DAT 0x20,0x42,0x59
   DAT 0x20,0x5A,0x45,0x52,0xCF
:ERR15 ;ILLEGAL DIRECT
   DAT 0x49,0x4C,0x4C,0x45,0x47,0x41,0x4C
   DAT 0x20,0x44,0x49,0x52,0x45,0x43,0xD4
:ERR16 ;TYPE MISMATCH
   DAT 0x54,0x59,0x50,0x45
   DAT 0x20,0x4D,0x49,0x53,0x4D,0x41,0x54,0x43,0xC8
:ERR17 ;STRING TOO LONG
   DAT 0x53,0x54,0x52,0x49,0x4E,0x47
   DAT 0x20,0x54,0x4F,0x4F
   DAT 0x20,0x4C,0x4F,0x4E,0xC7
:ERR18 ;FILE DATA
   DAT 0x46,0x49,0x4C,0x45
   DAT 0x20,0x44,0x41,0x54,0xC1
:ERR19 ;FORMULA TOO COMPLEX
   DAT 0x46,0x4F,0x52,0x4D,0x55,0x4C,0x41
   DAT 0x20,0x54,0x4F,0x4F
   DAT 0x20,0x43,0x4F,0x4D,0x50,0x4C,0x45,0xD8
:ERR1A ;CAN'T CONTINUE
    DAT 0x43,0x41,0x4E,0x27,0x54
    DAT 0x20,0x43,0x4F,0x4E,0x54,0x49,0x4E,0x55,0xC5
:ERR1B ;UNDEF'D FUNCTION
    DAT 0x55,0x4E,0x44,0x45,0x46,0x27,0x44
    DAT 0x20,0x46,0x55,0x4E,0x43,0x54,0x49,0x4F,0xCE
:ERR1C  ;VERIFY
    DAT 0x56,0x45,0x52,0x49,0x46,0xD9
:ERR1D  ;LOAD
    DAT 0x4C,0x4F,0x41,0xC4

; error message address locations

:ROMA326    DAT 0  ; ???
   DAT ERR01   ; 01 too many files
   DAT ERR02   ; 02 file open
   DAT ERR03   ; 03 file not open
   DAT ERR04   ; 04 file not found
   DAT ERR05   ; 05 device not present
   DAT ERR06   ; 06 not input file
   DAT ERR07   ; 07 not output file
   DAT ERR08   ; 08 missing file name
   DAT ERR09   ; 09 illegal device number
   DAT ERR0A   ; 0A next without for
   DAT ERR0B   ; 0B syntax
   DAT ERR0C   ; 0C return without gosub
   DAT ERR0D   ; 0D out of data
   DAT ERR0E   ; 0E illegal quantity
   DAT ERR0F   ; 0F overflow
   DAT ERR10   ; 10 out of memory
   DAT ERR11   ; 11 undef'd statment
   DAT ERR12   ; 12 bad subscript
   DAT ERR13   ; 13 redim'd array
   DAT ERR14   ; 14 devision by zero
   DAT ERR15   ; 15 illegal direct
   DAT ERR16   ; 16 type mismatch
   DAT ERR17   ; 17 string too long
   DAT ERR18   ; 18 file data
   DAT ERR19   ; 19 formula too complex
   DAT ERR1A   ; 1A can't continue
   DAT ERR1B   ; 1B undef'd function
   DAT ERR1C   ; 1C verify
   DAT ERR1D   ; 1D load
   DAT ROMA381   ; 1E break

; other messages

; ok

:ROMA364   DAT CBM_RETURN, "OK", CBM_RETURN
:ROMA368   DAT 0

; error

:ROMA369   DAT "  ERROR"
:ROMA370   DAT 0

; in

:ROMA371   DAT " IN "
:ROMA375   DAT 0

; ready.

:ROMA376   DAT CBM_RETURN, "READY.", CBM_RETURN
:ROMA380   DAT 0

; break

:ROMA381   DAT CBM_RETURN,0x0A

:ROMA383   DAT "BREAK"

:ROMA388   DAT 0x00

:ROMA389   DAT 0xA0

.include "loadsave.dasm16"

:FNDFOR
; Search for "FOR" blocks on stack containing
; the current variable.  If found, returns the
; stack location as X, and Z=1.  Otherwise, Z=0
:ROMA38A    SET Z, 0
            SET X, SP
            ADD X, 2 ; make allowance for two JSRs 
:ROMA38F    IFN [X], BASIC_FOR_TOKEN ; FOR block
                RTS ; not a FOR block.
:ROMA39A    IFE [FORPNT], 0
            	SET [FORPNT], [X+1]
:ROMA3A4    SET A, [X+1]
            IFE [FORPNT], A
                JMP ROMA3B7
:ROMA3B0    ADD X, 11
            JMP ROMA38F
:ROMA3B7    SET Z, 1 ; "found" result
            RTS

:BLTU
; ----------------------------------------------------------------------------
; MOVE BLOCK OF MEMORY UP
;
; ON ENTRY:
;   (Y,A) = (HIGHDS) = DESTINATION END+1     (58)
;   (LOWTR) = LOWEST ADDRESS OF SOURCE       (5F)
;   (HIGHTR) = HIGHEST SOURCE ADDRESS+1      (5A)
; ----------------------------------------------------------------------------
; Parameters in [LOWTR], [HIGHTR], and [HIGHDS]
;               and A should contain the value of [HIGHDS].
; RETURN: ?
:ROMA3B8        JSR REASON      ; garbage collect?
                SET [STREND], A ; returned start of free RAM
:BLTU2
:ROMA3BF        SET B, [LOWTR] ; source start address
                SET J, [HIGHTR] ; source end address
                IFE J, B    ; move no bytes
                    RTS
                ; pre-decrement
                STD I, [HIGHDS] ; destimation end address
:ROMA3BG        STD [I], [J]
                IFN J, B
                    JMP ROMA3BG
                SET [I], [J] ; last byte
                RTS

; test for A bytes free on stack
:GETSTK
    ADD A, STACK+52
    IFG A, SP
        JMP OMERR
    RTS

; ----------------------------------------------------------------------------
; CHECK IF ENOUGH ROOM BETWEEN ARRAYS AND STRINGS
; (A) = ADDR ARRAYS NEED TO GROW TO
; ----------------------------------------------------------------------------
:REASON
:ROMA408    IFL A, [FREETOP]
                RTS
            SET PUSH, A
            JSR GARBAG
            SET A, POP
            ; garbage collection not enough?
            IFG A, [FREETOP]
                JMP OMERR
:ROMA434    RTS

; out of memory error
:OMERR
:ROMA435     SET X, 16  ; ?OUT OF MEMORY

; handle error messages
:ERROR
:ROMA437     JMP_IND IERROR   ; snall detour in the kernal
:BASIC_ERROR
:ROMA43A     SET [INDEX], [ROMA326+X]
             JSR CLRCHN
             SET [CHANNL], 0
:ROMA44E     JSR ROMAAD7 ; end line on CMD
:ROMA451     JSR OUTQUES
             SET Z, [INDEX]   ; LDY #$00
:ROMA456     SET A, [Z]       ; LDA ($22),Y
             SET PUSH, A      ; PHA
            
            AND A, 0x7F      ; AND #$7F
            SET PUSH, Z
             JSR ROMAB47   ; CHROUT
            SET Z, POP
             ADD Z, 1            ; INY
            SET A, POP 
            IFC A, 0x80       ; PLA
                JMP ROMA456  ; BPL $A456
             JSR ROMA67A ; clear some basic variables
             SET A, ROMA369  ; "  ERROR"
:ROMA469     JSR STROUT
             IFL [CURLIN], 0xFF00  ;If not in immediate node
                 JSR ROMBDC2      ; display "IN <line>"

:READY
:ROMA474     SET A, ROMA376   ; "READY."
             JSR STROUT
             SET A, 0x80
:ROMA47D     JSR SETMSG
; main loop
:MAIN
:ROMA480    JMP_IND IMAIN ; normally ROMA483
:DEF_MAIN
:ROMA483    
            ; debugging is useful
            IFE DEBUGPROGMEM, 0
                JMP SKIPBMEM
            SET I, SCREENMEM
            SET J, BASICMEM
:BMEMLOOP
            STI [I], [J]
            BOR [I-1], 0x0100
            IFL I, SCREENMEM+32
                JMP BMEMLOOP
:SKIPBMEM
            JSR INLIN ; address of line input in X
            SET [RAM7A], X
:ROMA48A    JSR CHRGET 
:ROMA48D    SET X, A ; TAX
:ROMA48E    IFE A, 0  ; BEQ $A480 
                JMP_IND IMAIN   ; which was this JMP
            SET [CURLIN], -1 ; enter immediate mode
            IFE C, 0 ; begins with a digit
               JMP MAIN1 ; add line to program
            ; parse statement in immediate mode
            JSR CRUNCH ; token cruncher
            JMP ROMA7E1 ; execute a statement

; handle insert/delete basic lines
:MAIN1
:NUMBERED_LINE
:ROMA49C    JSR LINGET   ; get decimal number into [LINNUM]
            JSR CRUNCH   ; token cruncher
            ; why is this too short?
            SET [COUNT], Y  ; cache length of line
            JSR FINDLN  ; search for line A
            IFE C, 0 ; line number not found
                JMP ROMA4ED  ; insert only
; Delete old line.
:ROMA4A9    SET I, [LOWTR] ; Pointer to matched line
            SET J, [I]     ; Pointer to following line
            STD B, [VARTAB] ; End of program text
            SUB B, J
            ADD B, I       ; End when line is removed.
            SET [VARTAB], B ; reclaim memory for variables
            ; due to the fact that zero is always a 16-bit zero,
            ; and never the high byte of a small number, 
            ; we might be able to relink the program within the
            ; loop instead of the old way.
:ROMA4A9L
            STI [I], [J]
            IFL I, B
                JMP ROMA4A9L
            SET [I], [J]
; insert new line.
:ROMA4ED    JSR SETPTRS ; clear variable memory
            JSR FIX_LINKS ; relink basic program
            IFE [RAM0200], 0   ; No text entered
                JMP MAIN ; delete only; return to prompt
            ; Make room for new line by moving the rest
            ; of the program up
:ROMA4F8    SET A, [VARTAB]
            SET [HIGHTR], A  ; source end address + 1
            ADD A, [COUNT]  ; add number of characters
            SET [HIGHDS], A  ; destination end address + 1
            JSR BLTU        ; Move memory
            SET [RAM01FF], [LINNUM]
:ROMA517    SET [VARTAB], [STREND]
            SET Y, [COUNT]
            SUB Y, 1
            ; copy line into memory
            SET I, [LOWTR] ; pointer to new spot in memory
            ADD I, Y
            STI J, RAM01FE
            ADD J, Y
:ROMA522L
            STD [I], [J]
            IFN J, RAM01FE
                JMP ROMA522L
:ROMA52A    JSR SETPTRS ; clr?
            JSR FIX_LINKS
            JMP_IND IMAIN

; ----------------------------------------------------------------------------
; CLEAR ALL VARIABLES
; RE-ESTABLISH ALL FORWARD LINKS
; ----------------------------------------------------------------------------
:FIX_LINKS
:ROMA533    
            SET I, [TXTTAB]
            SET J, I   ; note beginning of line
:ROMA53C    IFE [I+1], 0 ; no link; must be end of program
                RTS
            ADD I, 1   ; skip over line number
:ROMA544    ADD I, 1   ; go to next character
            IFN [I], 0
                JMP ROMA544
            ADD I, 1
:ROMA54A    SET [J], I  ; link from beginning of line to current location
:ROMA559    SET J, I    ; use current location for next link
:ROMA55D    JMP ROMA53C 

; Get a line from the console.
; input stored in RAM0200, zero-terminated
:INLIN
:ROMA560    SET X, 0
:ROMA562    JSR ROME112   ; GETIN -> ROMF157
            IFE A, CBM_RETURN 
                JMP ROMAACA ; mark end and return
            SET [RAM0200+X], A
            ADD X, 1
            IFU X, HW_COLS*ROWS_IN_LINE
                JMP ROMA562
            IFE DEBUG_SNERR, 0
                JMP LTLERR
            ; to help diagnose screen editor issues.
            ; how long did it think the line was?
            SET A, X
            JSR LINPRT
            ;SET A, 62
            ;JSR CHROUT
            ;SET A, HW_COLS*ROWS_IN_LINE
            ;JSR LINPRT
            SET A, CBM_RETURN
            JSR CHROUT
            SET A, CBM_RETURN
            JSR CHROUT

:LTLERR
            SET X, 0x17 ; ?LINE TOO LONG
            JMP ERROR
            
; Standard Token Cruncher
; Throughout this routine, X contains the address
; of the characters being evaluated.
; RAM0F is used to disable tokenization after a DATA statement.
; Y returns the length of the string plus 2, not including line number 
; 2 is added so that when the crunched string is copied into program
; memory, it is copied along with an extra word for the line number,
; and an extra word into which the link to the next line will be stored.
; That is why everything indexed from [RAM01FE] instead of [RAM0200]
; directly, and why everything in the 6502 version indexed from $01FC.
:CRUNCH
:ROMA579    JMP_IND ICRNCH
:DEF_CRUNCH
:ROMA57C    SET X, [RAM7A] 
            SET Y, 2    ; first two characters are taken up by link &c
            SET [RAM0F], Y
:ROMA582    SET A, [X]
            IFC A, 0x80  ; BPL, unshifted character.
                JMP ROMA58E
            IFE A, 0xFF ; pi
                JMP ROMA5C9
            ADD X, 1
            JMP ROMA582 ; ignore, go to next
:ROMA58E    IFE A, CBM_SPACE
                JMP ROMA5C9
            SET [ENDCHR], A
            IFE A, CBM_QUOTE
                JMP ROMA5EE ; skip to next quote
            IFB [RAM0F], 0x40 ; BVS
                JMP ROMA5C9 ; Quote mode for DATA statement
            IFN A, 0x3F ; question mark
                JMP ROMA5A4
            SET A, BASIC_PRINT_TOKEN 
            JMP ROMA5C9
            ; the REM test line should get at least this far
:ROMA5A4    IFL A, 0x30 ; Zero
                JMP ROMA5AC ; not a digit
:ROMA5A8    IFL A, 0x3C ; Digit
                JMP ROMA5C9
:ROMA5AC    SET [RAM71], Y  ; cache position in thing
            SET [COUNT], 0  ; start at first token
            SET Y, -1       ; start at first byte of token table
            SET [RAM7A], X
            SUB X, 1
; Loop through input buffer and token, see if they match.
:ROMA5B6    ADD Y, 1 ; does next character of token table...
            ADD X, 1 ; match the next byte of the input?
; loop section 1
:ROMA5B8    SET A, [X]
:ROMA5BC    XOR A, [TOKEN_NAMES+Y]
            IFE A, 0
                JMP ROMA5B6
:ROMA5C1    ; 0x80 matches both the final character of
            ; a full command, or the shifted final character
            ; of an abbreviated command.
            IFN A, 0x80
                JMP ROMA5F5            
            BOR A, [COUNT]  ;A = Token = 0x80 + token's position in list
:ROMA5C7    SET Y, [RAM71]
:ROMA5C9    ADD X, 1 ; Move to next character in buffer
            ADD Y, 1 ; Move to...?
            SET [RAM01FD+Y], A
            IFE A, 0  ; end of line
                JMP ROMA609
:ROMA5D4    SUB A, CBM_COLON
            IFE A, 0
                JMP ROMA5DC
            IFN A, BASIC_DATA_TOKEN-CBM_COLON ; DATA token
                JMP ROMA5DE
:ROMA5DC    SET [RAM0F], A ; Set quote mode ON for DATA
:ROMA5DE    IFN A, BASIC_REM_TOKEN-CBM_COLON
                JMP ROMA582 ; just move to next character
            SET [ENDCHR], 0 
            ; Copy characters literally until either
            ; end of line, or whatever's in [ENDCHR].
:ROMA5E5    SET A, [X]
            IFC A, 0xFF
                JMP ROMA5C9
:ROMA5EA    IFE A, [ENDCHR]
                JMP ROMA5C9
:ROMA5EE    ADD Y, 1
            SET [RAM01FD+Y], A
            ADD X, 1
            IFB X, 0xFF ; BNE in 8-bit
                JMP ROMA5E5
            ; Jumped here from string matcher above,
            ; when a token didn't match.  Return to beginning
            ; of token, and try the next one.
:ROMA5F5    SET X, [RAM7A]  ; Restore original source pointer
            ADD [COUNT], 1
            ; Skip past end of this token
:ROMA5F9    ADD Y, 1
            IFC [TOKEN_NAMES-1+Y], 0x80
                JMP ROMA5F9
            IFN [TOKEN_NAMES+Y], 0
                JMP ROMA5B8 ; Try next token
:ROMA604    SET A, [X]
            IFC A, 0x80 ; unshifted
                JMP ROMA5C7
            ; branches here if null character found
:ROMA609    SET [RAM01FE+Y], A  ; ends with two NULLs in a row
            SET [RAM7A], RAM0200-1
            RTS

; SEARCH for a line in a program
; pass address of first line to check in A (originally A+X)
; returns C=1 and address in LOWTR if found
; returns C=0 if not found

:FINDLN
:ROMA613    SET A, [TXTTAB]     ; $2B
:FINDLNA
:ROMA617    SET I, 1
            SET [LOWTR], A
            ADD I, [LOWTR]  ; I = NEXT line in linked list
            IFE [I], 0 ; if address of that line is 0
                JMP ROMA640
            SET A, [LINNUM]
            IFL A, [I]
                JMP ROMA640 ; return "not found"
            SET C, 1    ;since last one was a BCC
            IFE A, [I]
                RTS    ; return "found"
:ROMA637    SET A, [I-1]
            JMP FINDLNA  ; Check line after next. 
:ROMA640    SET C, 0 ; return "not found"
            RTS
            
; NEW command

:STMT_NEW
:ROMA642    IF_NOT_NEXT_STMT
                RTS
:SCRTCH
:ROMA644    SET I, [TXTTAB]
            STI [I], 0
            STI [I], 0
            SET [I], 0
            SET [VARTAB], I
:SETPTRS
:ROMA659    JSR STXTPT ; set execution pointer to [TXTTAB]-1

:ROMA65C    SET A, 0     ;LDA #$00
            SET Z, 1
; CLR command

:STMT_CLR
:ROMA65E    IF_NOT_NEXT_STMT
                RTS   ; BNE $A68D            
:ROMA660    JSR CLALL
:ROMA663    SET [FREETOP], [MEMSIZ]
            ;SET EX, 0xA663
            ;IFE [VARTAB], 0
            ;   JMP VARTABCRASH
            SET [ARYTAB], [VARTAB]
            SET [STREND], [VARTAB]  ; set start of free RAM
:ROMA677    JSR STMT_RESTORE

; reset stack and program pointers

:ROMA67A    SET [TEMPPT], TEMPST  ;String pointer stack
            SET A, POP ; Pull RTS location
            SET SP, STACKBASEND  ; LDX #$FA
            SET PUSH, A
            SET [OLDTXT], 0
            SET [SUBFLG], 0
:ROMA68D    RTS

; ----------------------------------------------------------------------------
; SET TXTPTR TO BEGINNING OF PROGRAM
; ----------------------------------------------------------------------------
:STXTPT
:ROMA68E    SET A, [TXTTAB]
            SUB A, 1
            SET [RAM7A], A
            RTS

:STMT_LIST
:ROMA69C    IF_IS_DIGIT     ; LIST line
                JMP ROMA6A4
            IF_NEXT_STMT    ; LIST all
                JMP ROMA6A4
            IFN A, BASIC_MINUS_TOKEN ; LIST -end
                RTS
:ROMA6A4    JSR LINGET
            JSR FINDLN ; 
            JSR CHRGOT
            IF_NEXT_STMT  ; no end line specified
                JMP ROMA6BB
            IFN A, BASIC_MINUS_TOKEN  ; range to end
                RTS
            JSR CHRGET
            JSR LINGET
            IFE Z, 0  
                RTS
                ; pop?
:ROMA6BB    SET A, POP
            SET A, POP
            IFN [LINNUM], 0
                JMP ROMA6C9
            SET [LINNUM], -1
; LIST LINES from LOWTR to LINNUM
:ROMA6C9    SET [RAM0F], 1
            SET Y, [LOWTR]
:ROMA6CD    IFE [Y], 0     ; no link to next line
                JMP ROMA714
            JSR ROMA82C ; check STOP key
            JSR ROMAAD7 ; end line on output file
            ADD Y, 1
            IFG [Y], [LINNUM]  ; beyond end line
                JMP ROMA714 ; break out of loop
            SET [FORPNT], Y
:ROMA6EA    SET A, [Y]
            JSR LINPRT
            SET A, CBM_SPACE ; space following line number
:ROMA6EF    SET Y, [FORPNT]
:ROMA6F1    AND A, 0x7F ; filter high bit if coming from QPLOP
            ; loop to print a line
:ROMA6F3    JSR ROMAB47 ; print character
            IFE A, CBM_QUOTE
            XOR [RAM0F], -1 ; enter quote mode
            ADD Y, 1
            ;IFE Y, 0  ; what, stop after 256 characters?
            ;   JMP ROMA714
            SET A, [Y]
            IFN A, 0
                JMP QPLOP ; Print with tokens expanded
            SET Y, [LOWTR] ; follow link to nxt line
            SET [LOWTR], [Y] ; cache link to line after that
            IFN [Y], 0
                JMP ROMA6C9
:ROMA714    JMP ROME386 

; Standard Token Printer
:QPLOP
:ROMA717    JMP_IND IQPLOP
:DEF_QPLOP
:ROMA71A    IFL A, 0x80 ; Low ASCII
                JMP ROMA6F3   ; print literal
            IFE A, 0xFF ; PI
                JMP ROMA6F3   ; print literal
            IFB [RAM0F], 0x8000 ; BMI
                JMP ROMA6F3   ; print literal
            ; token value detected
:ROMA724    SUB A, 0x7F
            SET [FORPNT], Y
            SET Y, TOKEN_NAMES-1
:ROMA72C    SUB A, 1 ; Next token
            IFE A, 0
                JMP ROMA737
:ROMA72F    ADD Y, 1 ; Next character in token
            IFC [Y], 0x80
                JMP ROMA72F ; Next character
            JMP ROMA72C    ; next token
            ; print keyword
:ROMA737    ADD Y, 1
            SET A, [Y]
            IFB A, 0x80 ; end of token
                JMP ROMA6EF  ; print last character and return to loop
            JSR ROMAB47 ; print character in token
            JMP ROMA737

; FOR statement
; calls STMT_LET and pushes 11 words onto the stack:
;    pointer to first statement in loop      @ 10
;    line number of same                     @ 9
;    TO target as 3-word float               @ 6-8   
;    STEP increment as 4-word float          @ 2-5   
;    pointer to variable being incremented   @ 1   
;    FOR token                               @ 0 - shallow  

:STMT_FOR
:ROMA742    SET [SUBFLG], 0x80
            JSR STMT_LET
            JSR FNDFOR  ; check whether we're resuming a FOR loop
            IFE Z, 0 ;
                JMP ROMA753
            ; we're already looping on this variable
            ADD X, 10  ; is this right?
            SET SP, X  ; purge that loop from the stack 
:ROMA753    SET A, POP ; discard JSR
            SET A, 11   ; test for this many bytes available
            JSR GETSTK
            JSR DATAN ; get end of statement
            SET PUSH, I        ; push first statement in loop ; +1
            SET PUSH, [CURLIN] ; push line number             ; +1
            SET A, BASIC_TO_TOKEN   ; TO token
            JSR SYNCHR
            JSR CHKNUM  ; left side of TO must be numeric
            JSR FRMNUM   ; get number on right side of TO
            ; Compress FACSGN into FACHO;
            ; pushing only 3 words.
            SET A, [FACSGN]
            BOR A, 0x7FFF
            AND A, [FACHO]
            SET [FACHO], A
            SET I, ROMA78B  ; return vector
            JMP ROMAE43 ; push TO target value    +3
            ; it returns here
:ROMA78B    SET A, FONE ; STEP 1 by default
            JSR MOVFM
            JSR CHRGOT
            IFN A, BASIC_STEP_TOKEN  ; STEP token?
                JMP ROMA79F
            JSR CHRGET
            JSR FRMNUM ; get STEP value
:ROMA79F    JSR SIGN
            JSR ROMAE38  ; push STEP with separate sign byte +4
            SET PUSH, [FORPNT] ; pointer to increment variable +1
            SET PUSH, BASIC_FOR_TOKEN

; execute next statement

:NEWSTT
:ROMA7AE    JSR ROMA82C ; check STOP key
:ROMA7B1    ; Skip OLDTXT setting if executed line is in
            ; the RAM0200 range, i.e. in immediate mode
            SET A, [RAM7A]
            IFL A, RAM0200
                JMP ROMA7BA
            IFG A, RAM0200+BASIC_BUFFER_LENGTH-1
                JMP ROMA7BA
            JMP ROMA7BE
            ; set CONT return position
:ROMA7BA    SET [OLDTXT], [RAM7A]
; instead of using Y to index, we store the whole
; address in Z.
:ROMA7BE    SET Z, [RAM7A]
:ROMA7C0    SET A, [Z]
:ROMA7C2    IFN A, 0 ; NOT end of line
              JMP ROMA807 ; consume required colon and continue
:ROMA7C4    SET A, [Z+1] ; check link to next line
:ROMA7C8    SET C, 0  ; hide "BREAK" message
:ROMA7C9    IFE A, 0  ; no line following this one
                JMP ROMA84B   ; end program

            ADD Z, 2  ; get new current line number
            SET [CURLIN], [Z]
            SET [RAM7A], Z
:ROMA7E1    JMP_IND RAM0308   ; normally A7E4

:GONE    ; execute a statement
:ROMA7E4    JSR CHRGET    ; get token into A
            JSR ROMA7ED   ; execute command in token
            JMP NEWSTT    ; move to next statement

; execute command  at RAM7A.
; its first character or token is in A
:ROMA7ED    IF_NEXT_STMT  ; If zero bit set
                RTS
:ROMA7EF    SUB A, 0x80
            IFU A, 0   
                JMP STMT_LET ; simple variable assignment
:ROMA7F3    IFG A, 0x22 ; number of commands
                JMP ROMA80E
            SET PUSH, [TOKEN_ROUTINES+A] ; get address of next command
            JMP CHRGET
            ; will return to STMT_* with next character in A, C, Z.
:ROMA807    IFE A, CBM_COLON
                JMP ROMA7E1
            JMP SNERR
            ; handle "GO TO" with a space in it
:ROMA80E    IFN A, 0x4B ; GO code
                JMP SNERR
            JSR CHRGET
            SET A, BASIC_TO_TOKEN   ; TO code
            JSR SYNCHR
            JMP STMT_GOTO

; end line on CMD output file

:STMT_RESTORE
:ROMA81D    SET A, [TXTTAB]        
            SUB A, 1      
:ROMA827    SET [DATPTR], A 
            RTS
; test STOP key for break in program
:ROMA82C     JSR STOP
; will set carry bit if pressed

; STOP command
; is basically END with the carry bit set,
; so that the BREAK message appears.
:STMT_STOP
:ROMA82F    IFN C, 0      ; BCS $A832
                JMP ROMA832

; END command
:STMT_END
            SET C, 0      ; CLC
:ROMA832    IF_NOT_NEXT_STMT     ; Not end of statement
                RTS
:ROMA834    SET A, [RAM7A]      
:ROMA838    IFG [CURLIN], 0xFF00 ; in immediate mode
                JMP ROMA849  
            SET [OLDTXT],[RAM7A]  ; set return point
            SET [OLDLIN],[CURLIN] ; for CONT
:ROMA849    SET A, POP      ; don't return to NEWSTT
:ROMA84B    SET A, ROMA381 ; "BREAK"
            IFE C, 0 ; not really a break
                JMP ROME386
            JMP ROMA469  ; go to READY prompt

:STMT_CONT
:ROMA857    IFE Z, 1
                RTS
            SET X, 0x1A ; ?CAN'T CONTINUE ERROR
            IFL [OLDTXT], 0x100
                SET PC, ERROR 
            SET [RAM7A],[OLDTXT]
            SET [CURLIN],[OLDLIN]   
            RTS

; RUN command

:STMT_RUN
:ROMA871    SET PUSH, Z
            SET A, 0 
            JSR SETMSG
            SET Z, POP
            IF_NEXT_STMT ; Not zero
                JMP SETPTRS ; clear variable memory

:ROMA87D    JSR ROMA660      ; do CLR
            JMP ROMA897      ; do GOTO

; GOSUB command

:STMT_GOSUB
:ROMA883    SET A, 3
            JSR GETSTK    ; check for room in the stack
            ; originally pushed 5 bytes to stack,
            ; now pushes 3 words
            SET PUSH, [RAM7A]
            SET PUSH, [CURLIN]
            SET PUSH, BASIC_GOSUB_TOKEN  ; to signify a GOSUB

:ROMA897    JSR CHRGOT

            JSR STMT_GOTO
            JMP NEWSTT  ; execute next statement

; GOTO command

:STMT_GOTO
:ROMA8A0    JSR LINGET  ; get target line
            JSR REMN  ; Set I to the 0 at the end of this line
            SET A, I ; start at next line
            ADD A, 1 ; skip over null 
            IFG [CURLIN], [LINNUM]
                SET A, [TXTTAB] ; start at beginning
            IFE [CURLIN], [LINNUM]
                SET A, [TXTTAB] ; start at beginning
            JSR FINDLNA ; set [LOWTR] to address of target
            IFE C, 0        ; line not found
                JMP ROMA8E3 ; throw ?UNDEF'D STATEMENT
:ROMA8C5    SET A, [LOWTR]
            SUB A, 1
:ROMA8C9    SET [RAM7A], A  ; got new location
            RTS

; RETURN command
:STMT_RETURN
:ROMA8D2    IF_NOT_NEXT_STMT
                RTS
            BOR [FORPNT], 0xFF00 ; in case GOSUB from immediate
            JSR FNDFOR   ; Search for FOR blocks on stack
            SET SP, X
            IFE PEEK, BASIC_GOSUB_TOKEN ; CMP #$8D   ; GOSUB
                JMP ROMA8EB
            SET X, 0x0C  ; ?RETURN WITHOUT GOSUB
            IFN X, 0x0C  ; skip next
:ROMA8E3    SET X, 0x11 ; ?undef'd statment
                JMP ERROR

; Remove GOSUB block from stack
:ROMA8EB    SET A, POP ; consume GOSUB token
            SET [CURLIN], POP
            SET [RAM7A], POP

:STMT_DATA
:ROMA8F8    JSR DATAN ; get end of statement
            ; instead of returning number to add in Y,
            ; returns complete address in I.
:ROMA8FB        SET [RAM7A], I
            RTS

; GET END OF LINE
; returns address of next line in I, ready for RAM7A.
; (original returned number to add in Y)
; There's a way to use registers instead of ENDCHR and CHARAC,
; but when I try, program entry breaks somehow.
:DATAN
:ROMA906    SET [CHARAC], CBM_COLON   ; get next statement
            IFE 1, 0 ; skip
:REMN
:ROMA909    SET [CHARAC], 0           ; get end of line
:ROMA90D    SET I, [RAM7A]
            SET [ENDCHR], 0
            SET Z, 0
:ROMA911    SET A, [ENDCHR]    ; swap CHARAC and ENDCHR
            SET [ENDCHR], [CHARAC]
            SET [CHARAC], A
:ROMA919    SET A, [I] 
            IFE A, 0
                SET Z, 1
            IFE A, 0
                RTS
:ROMA91D    IFE A, [ENDCHR]
                RTS
            ADD I, 1
            IFE A, CBM_QUOTE ; quote mark
                JMP ROMA911
            JMP ROMA919

:STMT_IF
:ROMA928    JSR FRMEVAL
            JSR CHRGOT
            IFE A, BASIC_GOTO_TOKEN
                JMP ROMA937
            SET A, BASIC_THEN_TOKEN
            JSR SYNCHR
:ROMA937    SET C, 0
            SET A, [FACEXP] ; get result of FRMEVAL
            IFN A, 0        ; result is TRUE
                JMP STMT_THEN

:STMT_REM
:ROMA93B    JSR REMN ; get end of line
            JMP ROMA8FB ; was BEQ

:STMT_THEN
:ROMA940    JSR CHRGOT
            IF_NOT_DIGIT    ; THEN <command>
                JMP ROMA7ED ; execute command
            JMP STMT_GOTO ; THEN <line number>

:STMT_ON
:ROMA94B    JSR GETBYT  ; Get result of expression after ON
            SET PUSH, A  ; cache token following the expression
            IFE A, BASIC_GOSUB_TOKEN
                JMP ROMA957
:ROMA953    IFN A, BASIC_GOTO_TOKEN
                JMP SNERR
            ; original used $65 -- low byte of a 16-bit, right?
:ROMA957    SUB [RAM64], 1
            IFN [RAM64], 0
                JMP ROMA95F ; skip
            SET A, POP  ; pop GOTO/GOSUB token
            JMP ROMA7EF ; evaluate as if a stand-alone command
:ROMA95F    JSR CHRGET  
            JSR LINGET  ; consume and discard line number
            IFE A, CBM_COMMA
            JMP ROMA957
            SET A, POP ; past end of list; do nothing.
            RTS         

; get decimal literal, i.e. a line number, into LINNUM.
; C should be zero coming in, and
; A should be the result of a CHRGET.
; throws an illegal quantity error if over 63999.

:LINGET
:ROMA96B    SET X, 0
            SET [LINNUM], 0
:ROMA971    IF_NOT_DIGIT
                RTS
            SUB A, 0x30   ; get value of ASCII digit
            IFG [LINNUM], 6399 ; about to be >64000
                JMP SNERR
            MUL [LINNUM], 10
            ADD [LINNUM], A
            JSR CHRGET
            JMP ROMA971 ; get next digit or return


; LET command
:STMT_LET
:ROMA9A5    JSR PTRGET ; get variable from name as I
            ; should return an address, and 
            ; leave the cursor before the = sign following
            SET [FORPNT], I ; assignments use FORPNT instead of VARPNT
            SET A, BASIC_EQ_TOKEN
            JSR SYNCHR
            SET PUSH, [INTFLG]
            SET PUSH, [VALTYP]
            JSR FRMEVAL
            SET A, POP ; VALTYP of variable...
            SHL A, 1
            SET C, EX
            JSR CHKVAL  ; check that it's the correct type
            ; Z flag was result of BIT $0D
            AND A, [VALTYP]
            IFN A, 0
                JMP ROMA9D9  ; assign to string
:ROMA9C1    SET A, POP  ; INTFLG of variable
:ROMA9C2    IFC A, 0x80 ; BPL
                JMP ROMBBD0  ; assign to float

; assign to integer
:ROMA9C4    JSR ROUND
            JSR AYINT ; convert float to int
            SET A, [FORPNT]
            SET [A], [FACHO+1]  ; store int result
            RTS


;assign to string
:ROMA9D9    SET A, POP ; discard INTFLG from STMT_LET
:ROMA9DA    IFN [FORPNT], C_ZERO ; TI$? ($BF on C64, $D0 or $DE on others)
                JMP ROMAA2C
            ;assign to TI$
            JSR ROMB6A6
            IFN A, 6       ; length must be 6
                JMP FCERR  ; otherwise illegal quantity error
            SET Y, 0
            SET [RAM61], 0
            SET [RAM66], 0
:ROMA9ED    SET [RAM71], Y
            JSR ROMAA1D
            JSR MUL10
            ADD [RAM71], 1
            SET Y, [RAM71]
            JSR ROMAA1D
            JSR COPY_FAC_TO_ARG_ROUNDED
            SET X, A
            IFE A, 0
                JMP ROMAA07
            ADD X, 1
            SET A, X
            JSR ROMBAED
:ROMAA07    SET Y, [RAM71]
            ADD Y, 1
            IFN Y, 6
                JMP ROMA9ED
            JSR MUL10
            JSR ROMBC9B
            ; this is definitely wrong, but it
            ; should be simple to fix later
            SET X, [RAM64]
            ;SET Y, [RAM62] ; 63
            ;SET A, [RAM64]
            JMP SETTIM

; assign to variable string
:ROMAA2C    ;DAT 0x5000
            SET Y, [RAM64]
            SET A, [Y]
            SET B, [Y+1]
            ;SET C, [FREETOP]
            ;DAT 0x2000
            IFL [Y+1], [FREETOP]; beginning of string variable area
                JMP ROMAA4B ; points to a string already in memory
            IFL Y, [VARTAB] 
                JMP ROMAA4B ; points to a literal in BASIC
            JMP ROMAA52     ; 
:ROMAA4B    SET A, [RAM64] ; take pointer
            JMP ROMAA68    ; move descriptor into variable
:ROMAA52    SET A, [Y]
            JSR STRINI
            SET [RAM6F], [DSCPNT]  ;TODO: check order
            JSR MOVINS  ; move string
            SET A, FACEXP
; move 2-byte descriptor into variable
:ROMAA68    SET [DSCPNT], A
            JSR FRETMS ; herp derp stack
            SET J, [DSCPNT]
            SET I, [FORPNT]
            STI [I], [J]      ; length
            STD [I], [J]  ; address
            RTS

; add next digit to float accum

:ROMAA1D    SET A, [INDEX]
            ADD A, Y
            SET A, [A]  ; LDA ($22),Y
            JSR RAM0080 ; verify is digit
            IFN C, 0 ; not a digit
                JMP FCERR
            SUB A, 0x30
:ROMAA29    JMP FINLOG

:STMT_PRINTN
:ROMAA80    JSR ROMAA86
            JMP ROMABB5

:STMT_CMD
:ROMAA86    JSR GETBYT
            IFE Z, 1  ; i think it ends in CHRGOT
                JMP ROMAA90
            SET A, CBM_COLON
            JSR SYNCHR
:ROMAA90    SET PUSH, Z
            SET X, [CHANNL]
            JSR ROME118
            SET Z, POP 
            JMP STMT_PRINT

; Print string and get next thing.
:ROMAA9A    JSR ROMAB21
:ROMAA9D    JSR CHRGOT
:STMT_PRINT
:ROMAAA0    IF_NEXT_STMT  ; print by itself, or non-semicolon-terminated
                JMP ROMAAD7 ; print CR
:ROMAAA2    IF_NEXT_STMT
                RTS
:ROMAAA4    IFE A, BASIC_TAB_TOKEN   ; TAB(
                JMP ROMAAF8
            SET C, 0
            IFE A, BASIC_SPC_TOKEN   ; SPC(
                JMP ROMAAF8
            IFE A, CBM_COMMA
                JMP ROMAAE8
            IFE A, 0x3B ; SEMICOLON
                JMP ROMAB13
            JSR FRMEVAL
            IFU [VALTYP], 0    ; string
                JMP ROMAA9A    ; print string and restart
            JSR FOUT    ; convert float to string
            JSR STRLIT  ; prepare string in memory
            JSR ROMAB21 ; print string in [INDEX]
            JSR OUTSP ; print space ?
            JMP ROMAA9D  ; was a BNE, probably unconditional
            
; zero-terminate this string
:ROMAACA    SET [RAM0200+X], 0
            ; return location of input buffer in X
            SET X, RAM0200-1
            SET Z, 0
            IFN [CHANNL], 0
                RTS
            SET Z, 1

; RETURN at end of line on PRINT
:ROMAAD7 
            SET A, CBM_RETURN  
            JSR ROMAB47
            IFC [CHANNL], 0x80
                JMP ROMAAE5
            SET A, 0x0A  ; newline
            JSR ROMAB47
:ROMAAE5    XOR A, 0xFF 
            SET Z, 0
            SET C, 0  ; clear BREAK flag
            RTS

; routine for printing TAB( and SPC(
:STMT_TAB
:ROMAAE8    SET C, 1
            JSR PLOT
            SET A, Y
            SUB A, 10
            ; TODO: FINISH
:ROMAAF8    SET PUSH, C
            SET C, 1
            JSR PLOT
            SET [RAM09], Y
            JSR GETBYTC
            IFN A, 0x29 ; close paren
                JMP SNERR
            SET C, POP
            IFE C, 0
                JMP ROMAB0F
:ROMAB09    SET X, A
            SUB A, 9
            IFU A, 0  ; carry clear
                JMP ROMAB0E
            SET C, 0
            JMP ROMAB13
:ROMAB0E    SET X, A
:ROMAB0F    ADD X, 1
:ROMAB10    SUB X, 1
:ROMAB11    IFN X, 0
                JMP ROMAB19
            ; handle semicolon
:ROMAB13    JSR CHRGET
            JMP ROMAAA2
:ROMAB19    JSR OUTSP ; print space. what does it return?
            IFN A, 0
                JMP ROMAB10

; print string form AY

:STROUT
:ROMAB1E    JSR STRLIT ; Scan and set up pointers
            
; print string from $22/$23 [INDEX]

:ROMAB21    JSR ROMB6A6  ; get address in X, length in A
            SET X, A         ; length to X
            SET Y, [INDEX]   ; address to Y
            ADD X, 1
:ROMAB28    SUB X, 1
            IFE X, 0
                RTS
            SET A, [Y]      ; character to A
            JSR ROMAB47 ; print 1 character
            ADD Y, 1
            IFN A, CBM_RETURN  ; cr?
                JMP ROMAB28
:ROMAB35    JSR ROMAAE5  ; write RETURN
            JMP ROMAB28

            
; print character on CMD output file
; calling functions should check A instead of Z

:OUTSP
:ROMAB3B    IFE [CHANNL], 0
                JMP ROMAB42
:ROMAB3F    SET A, 0x20   ; space
            IFE A, -1 ; skip next
:ROMAB42    SET A, CBM_RIGHT   
            IFE A, -1 ; skip next
:OUTQUES
:ROMAB45    SET A, 0x3F  ; question mark
:ROMAB47    JMP ROME10C

; ----------------------------------------------------------------------------
; INPUT CONVERSION ERROR:  ILLEGAL CHARACTER
; IN NUMERIC FIELD.  MUST DISTINGUISH
; BETWEEN INPUT, READ, AND GET
; ----------------------------------------------------------------------------
:INPUTERR
:ROMAB4D    SET A, [INPFLG]
            IFE A, INF_INPUT   ;0
                JMP RESPERR
            IFE A, INF_READ
                JMP ROMAB57
            SET Y, -1        ; GET
            JMP ROMAB5B
:ROMAB57    SET A, [DATLIN]
:ROMAB5B    SET [CURLIN], A ; Report error from other line.
            JMP SNERR
:RESPERR    IFE [CHANNL], 0   ; keyboard
                JMP ROMAB6B   ; ask for REDO
            SET X, 0x18 ; ?FILE DATA ERROR
            JMP ERROR

; ?REDO FROM START          
:ROMAB6B    SET A, REDOMSG
            JSR STROUT
            SET [RAM7A], [OLDTXT]
            RTS

:STMT_GET
			JSR ERRDIR  ; program use only
			IFN A, 0x23 ; GET#
			    JMP LC486
			JSR CHRGET
			JSR GETBYT
			SET A, CBM_COMMA
			JSR SYNCHR
			JSR CHKIN
			SET [CHANNL], X
:LC486		SET X, RAM0200+1
			SET [X], 0
			SET A, INF_GET
			JSR PROCESS_INPUT_LIST
			SET X, [CHANNL]
			IFN X, 0
			    JMP ROMABB7
			RTS 

:STMT_INPUTN
:ROMABA5    JSR GETBYT
            SET A, CBM_COMMA
            JSR SYNCHR
            SET [CHANNL], X
            JSR ROME11E   ; CHKIN
            JSR ROMABCE   ; go to main INPUT subroutine
:ROMABB5    SET A, [CHANNL]
:ROMABB7    JSR ROMFFCC   ; clear
            SET [CHANNL], X
            RTS

:STMT_INPUT
:ROMABBF    SET C, 0
            IFN A, CBM_QUOTE 
                JMP ROMABCE
            ; handle INPUT "PROMPT";A$
:ROMABC3    SET C, 1
            JSR STRTXT ; start consuming string
            SET A, 0x3B  ; semicolon
            JSR SYNCHR  ; finish consuming string
            JSR ROMAB21
:ROMABCE    JSR ERRDIR ; handle illegal use in direct mode
:ROMABD1    SET A, CBM_COMMA
            SET [RAM01FF], A
:ROMABD6    JSR NXIN ; get line into input buffer
            IFE [CHANNL], 0
                JMP ROMABEA
:ROMABDD    JSR ROMFFB7    ; get status
            AND A, 2
            IFE A, 0
                JMP ROMABEA
            JSR ROMABB5
            JMP STMT_DATA ; jump to end of statement
:ROMABEA    SET A, INF_INPUT
            IFN [RAM0200], 0
                JMP PROCESS_INPUT_LIST ; pass X as input buffer start
            IFN [CHANNL], 0
                JMP ROMABD6
            JSR DATAN ; get end of line in I
            JMP ROMA8FB ; ... = I, next statement.

; get line into input buffer
; X will be set to character before input buffer
:NXIN
:ROMABF9    IFN [CHANNL], 0
                JMP INLIN
            JSR OUTQUES ; print question mark
            JSR OUTSP   ; print space
:ROMAC03    JMP INLIN

:STMT_READ
:ROMAC06    SET X, [DATPTR]
            SET A, INF_READ 

; ----------------------------------------------------------------------------
; PROCESS INPUT LIST
;
; (X) IS ADDRESS OF INPUT DATA STRING
; (A) = VALUE FOR INPUTFLG
; ----------------------------------------------------------------------------
:PROCESS_INPUT_LIST
:ROMAC0D    SET [INPFLG], A ; INPUT command entry
            SET [INPPTR], X ; start search position
:PROCESS_INPUT_ITEM
:ROMAC15    JSR PTRGET  ; get variable pointer as I
            SET [FORPNT], I  ; we use FORPNT for assignments
            SET [OPPTR], [RAM7A]
            SET [RAM7A], [INPPTR] ; move cursor to reading location
            JSR CHRGOT
            IF_NOT_NEXT_STMT
                JMP INSTART
            IFN [INPFLG], INF_GET ; BVC
                JMP ROMAC41
            JSR ROME124 ; get one character
			SET [RAM0200], A
            SET X, RAM01FF
            JMP ROMAC4D
:ROMAC41    IFE [INPFLG], INF_READ
                JMP ROMACB8
            IFN [CHANNL], 0
                JMP_IND ROMAC4A
            JSR OUTQUES ; print question mark
:ROMAC4A    JSR NXIN ; get line into input buffer
:ROMAC4D    SET [RAM7A], X
:INSTART
:ROMAC51    JSR CHRGET
            IFA [VALTYP], -1 ; Numeric
                JMP ROMAC89
            IFN [INPFLG], INF_GET ; BVC
                JMP ROMAC65
:ROMAC5C    ADD X, 1
            SET [RAM7A], X
            SET A, 0
            SET [CHARAC], A
            JMP ROMAC71
:ROMAC65    SET [CHARAC], A
            SET EX, 1 ; add 1 to address if quote matches
            IFE A, CBM_QUOTE
                JMP ROMAC72
            SET [CHARAC], CBM_COLON
            SET A, CBM_COMMA
:ROMAC71    SET EX, 0
:ROMAC72    SET [ENDCHR], A
            SET A, [RAM7A]
            ADX A, 0
            JSR STRLT2  ; STRLIT for unquoted string
            SET [RAM7A], [RAM71] ; move cursor to after string
            JSR ROMA9DA ; assign to a string variable
            JMP INPUT_MORE ; handle any extra
:ROMAC89    JSR FIN ; convert string to float
            SET A, [INTFLG]
            JSR ROMA9C2 ; assign to float or integer.
:INPUT_MORE
:ROMAC91    JSR CHRGOT
            IF_NEXT_STMT
                JMP ROMAC9D
            IFE A, CBM_COMMA ; end of variable
                JMP ROMAC9D
            JMP INPUTERR ; process input errors
:ROMAC9D    SET [INPPTR], [RAM7A]
            SET [RAM7A], [OPPTR] ; return cursor to program listing
            JSR CHRGOT
            IF_NEXT_STMT
                JMP INPDONE  ; no more variables in statement
            JSR CHKCOM              ; OR, comma
            JMP PROCESS_INPUT_ITEM  ; followed by another variable
; find next DATA statement
:ROMACB8    JSR DATAN ; get next statement in I
; todo: finish this I pointer's trek through the program
            ADD I, 1 
            IFN A, 0
                JMP ROMACD1
:ROMACBF    SET X, 0x0D ; ?OUT OF DATA
            ADD I, 1
            IFE [I], 0 ; no next line?
                JMP ERROR ; throw
            ADD I, 1
            SET [DATLIN], [I]
:ROMACD1    SET [RAM7A], I
            JSR CHRGOT
            SET X, A
            IFN X, BASIC_DATA_TOKEN ; DATA code
                JMP ROMACB8
            JMP INSTART
; ---NO MORE INPUT REQUESTED------
:INPDONE
:ROMACDF    SET A, [INPPTR]
            IFE [INPFLG], INF_READ ; bpl
                JMP ROMA827 ; set next line's data stmt
            IFE [A], 0
                RTS
            IFN [CHANNL], 0
                RTS
:ROMACF4    SET A, EXIGNT
            JMP STROUT

:EXIGNT
:ROMACFC
    DAT "?EXTRA IGNORED", CBM_RETURN, 0
:REDOMSG
:ROMAD0C
    DAT "?REDO FROM START", CBM_RETURN, 0

; NEXT statement - see STMT_FOR
:STMT_NEXT
:ROMAD1E    IF_NOT_NEXT_STMT
                JMP ROMAD24
            SET I, 0     ; don't know which variable to advance
            JMP ROMAD27
:ROMAD24    JSR PTRGET   ; get variable to advance in I
:ROMAD27    SET [FORPNT], I
            JSR FNDFOR
            ; [FORPNT] contains the variable we're really looping
            IFE Z, 1    ; found the variable
                JMP ROMAD35
:ROMAD30    SET X, 0x0A ; ?NEXT WITHOUT FOR
            JMP ERROR
:ROMAD35    SET SP, X  ; synchronize stack with that FOR
            ; this discards any inner loops we've skipped
:ROMAD42    SET A, SP
            ADD A, 2   ; pointer to STEP value
            JSR MOVFM  ; set FAC1
            SET [FACSGN], PICK 5
:ROMAD4B    SET A, [FORPNT] ; pointer to loop variable
:ROMAD4F    JSR FADD        ; add to STEP value
            JSR ROMBBD0     ; set loop variable to result
            SET A, SP
            ADD A, 6   ; pointer to TO value
            JSR FCOMP ; compare TO value (I) with loop variable
            ; break out if comparison matches sign of STEP
            IFE A, PICK 5
                JMP ROMAD78
:ROMAD61    ; last time through loop
            SET [CURLIN], PICK 9
            SET [RAM7A], PICK 10
:ROMAD75    JMP NEWSTT
            ; end of loop
:ROMAD78    ADD SP, 11    ; pop FOR block from stack
            JSR CHRGOT
:ROMAD80    IFN A, CBM_COMMA
                JMP NEWSTT
            JSR CHRGET   ; it's NEXT X,Y -- do NEXT Y also
            JSR ROMAD24  ; must JSR so that the POP works.
 
; get formula, enforce that it is a number.
:FRMNUM
:ROMAD8A    JSR FRMEVAL
; check value to be numeric
:CHKNUM
:ROMAD8D    IFU [VALTYP], 0
                JMP ROMAD99
            RTS
:CHKSTR
; check value to be string
:ROMAD8F    IFA [VALTYP], -1
                JMP ROMAD99
            RTS
; check that VALTYP matches C flag
; (VALTYP is string if -1, C is string if >0)
:CHKVAL
:ROMAD90    IFU [VALTYP], 0
                JMP ROMAD97
            IFN C, 0
                JMP ROMAD99
            RTS
:ROMAD97    IFN C, 0
                RTS
:ROMAD99    SET X, 0x16  ; ?TYPE MISMATCH ERROR
            JMP ERROR

                    
; evaluate formula, store result in FAC
; sets [VALTYP] to 0 if result is a floating point number
;                 -1 if result is a string pointer
:FRMEVAL
:ROMAD9E    SUB [RAM7A], 1
            SET X, 0
            IFE X, 1 ; push X instead of A
; if we enter at ROMADA9, we push on the stack:
;   A from [OPMASK]
;   X from somewhere in TBL_OP's left column.
:ROMADA9    SET PUSH, A
:ROMADAA    SET PUSH, X 
            SET A, 1
            JSR GETSTK
            JSR EVAL ; get a single floating point number
            ;GARBDEBUG(0)
            SET [OPMASK], 0
            ; 
:ROMADB8    JSR CHRGOT
:ROMADBB    
; check for comparison operators.  This is a loop so that
; the combinations <>, <=, and => work.
            SUB A, BASIC_GT_TOKEN ; code for greater-than
            IFU A, 0
                JMP ROMADD7
            IFA A, 2         ;CMP #3
                JMP ROMADD7  ;BCS $ADD7
            SHL A, 1         ;CMP #$01
            IFL A, 1         ;ROL
                BOR A, 0x01  ;EOR #$01
            XOR A, [OPMASK]
            IFL A, [OPMASK]  ; can't use same symbol twice
                JMP SNERR    ; in same operator.
            SET [OPMASK], A
            JSR CHRGET
            JMP ROMADBB  ; check for more comparison operators
            ; done detecting comparison operators
:ROMADD7    SET X, [OPMASK] ; parameter for FRM_RELATIONAL
            IFN X, 0  ; comparison operator exists
                JMP FRM_RELATIONAL
            IFA A, -1 ; result from SUB above was positive
                JMP ROMAE58
            ADD A, BASIC_GT_TOKEN-BASIC_PLUS_TOKEN
            IFU A, 0   ; still less than 0
                JMP ROMAE58
            IFE [VALTYP], 0
                ADD A, 1
            IFC A, 0xFF  ; zero in 8-bit
                JMP CAT
:ROMADE8    IFC A, 0x100 ; Carry bit clear in original
                SUB A, 1
            MUL A, 2 ; originally multiplied by 3
            ; Y now contains an index into the operator table.
            SET Y, A
            ; if we're on the right side of an operator,
            ; this POPs the precedence of that operator,
            ; so we know whether to keep going or just
            ; return the value we have so far.
:FRM_PRECEDENCE_TEST
:ROMADF0    SET A, POP
            SET X, [TBL_OP+Y]
            SUB X, 1 ; testing for greater-or-equal
            IFG A, X
                JMP FRM_PERFORM1  ; perform stacked operation
            JSR CHKNUM ; check that term is numeric
:ROMADF9    SET PUSH, A
            ; the value of Y should be set to
            ; a TBL_OP offset at this entry point
:ROMADFA    JSR FRM_RECURSE
:ROMADFD    SET A, POP
            SET Y, [OPPTR]  ; = -1 on 6502 for compares
            IFL Y, 0x80    ; BPL
                JMP ROMAE19
            SET X, A
            IFE X, 0
                JMP GOEX ; pop ARG from stack and...?
            JMP FRM_PERFORM2 ; perform stacked operation
            ; will return to address at top of stack

; handle comparison operators
; the first instruction here was LSR $0D, which I think was there
; to both set VALTYP to "numeric" for all future BMI tests, while
; getting its carry bit from the low bit
; X should be 8, 4, or 2 depending on whether it's <, =, or >.
:FRM_RELATIONAL
:ROMAE07    SHR [VALTYP], 1
            SET C, EX
            SHR C, 15  ; C=1
            SET B, [VALTYP]
:ROMAE09    SHL X, 1
            BOR X, C ; X = X*2 + C
:ROMAE08    SUB [RAM7A], 1
            SET Y, TBL_OP_COMPARE-TBL_OP   ; point to ROMB016 
            SET [OPMASK], X  ; to result of that ROMAE07 shuffle?
            JMP FRM_PRECEDENCE_TEST

; compare orders of precedence
:PREFNC
:ROMAE19    IFL A, [TBL_OP+Y]
                JMP ROMADF9
            JMP FRM_PERFORM2
            
; ----------------------------------------------------------------------------
; STACK THIS OPERATION AND CALL FRMEVL FOR
; ANOTHER ONE
; ----------------------------------------------------------------------------
:FRM_RECURSE
:ROMAE20    
            SET PUSH, [TBL_OP+1+Y] ; push operator for RTS
            JSR ROMAE33  ; push FAC onto stack
            SET A, [OPMASK]
            ; X is set to the order of precedence of
            ; this operator.
            ; A is set to [OPMASK]
            JMP ROMADA9  ; call FRMEVAL on the right side.

; push FAC onto stack (4 WORDS)
; save rounded value of left operand
; X is set to the first column of the operator table
:ROMAE33    SET X, [TBL_OP+Y]
            SET A, [FACSGN]
            ; Other entry points are used by FOR
            ; statement to push floats.
:ROMAE38    SET I, POP
            SET PUSH, A
:ROMAE43    JSR ROUND
            SET PUSH, [FACHO+1]
            SET PUSH, [FACHO]
            SET A, [FACEXP]
            SET PUSH, A
            JMP I    ; instead of RTS

; apply comparison operator
; Pop ARG from stack (4 WORDS)
:ROMAE58    SET Y, -1
            SET A, POP
:GOEX
:ROMAE5B    IFE A, 0 ; oh wait, there's no operator
                JMP ROMAE80
; ----------------------------------------------------------------------------
; PERFORM STACKED OPERATION
;
; (A) = PRECEDENCE BYTE
; STACK:  1 -- CPRMASK
;   5 -- (ARG)
;   2 -- ADDR OF PERFORMER
; ----------------------------------------------------------------------------
:FRM_PERFORM1
:ROMAE5D    IFN A, 0x64   ; comparison operator
                JSR CHKNUM 
:ROMAE64    SET [OPPTR], Y
:FRM_PERFORM2
:ROMAE66    SET A, POP
            SET C, A
            AND C, 1  ; pass most significant bit as C for RELOPS
            SHR A, 1
            SET [RAM12], A ; store comparison result
            SET [ARGEXP], POP 
            SET [ARGHO], POP 
            SET [ARGHO+1], POP 
            SET A, POP
            SET [ARGSGN], A
            XOR A, [FACSGN]
            ASR A, 15
            SET [ARISGN], A
:ROMAE80    SET A, [FACEXP]
:ROMAE82    RTS

; get arithmetic element routine            
; convert a single numeric term, such as
; a number or variable name, from 
; ASCII text to a floating point number
:EVAL
:ROMAE83    JMP_IND RAM030A  
:DEF_EVAL
:ROMAE86    SET [VALTYP], 0   ; numeric
:ROMAE8A    JSR CHRGET
            IFE C, 0 ; is a digit
                JMP FIN  ; read number into float
:ROMAE92    JSR ISALPHA
            IFE C, 1 ; is alpha
                JMP ROMAF28  ; must be a variable...
:ROMAE9A    IFN A, 0xFF ; PI character
                JMP ROMAEAD
            SET A, PIVAL
            JSR MOVFM
            JMP CHRGET
:PIVAL      DAT 0x82, 0x490F, 0xDAA1  ; float value of PI
            ; not a digit, variable, or pi:
:ROMAEAD    SET C, 1 ; so FIN knows dot isn't a digit
            IFE A, 0x2E ; Decimal point
                JMP FIN ; read a number
            IFE A, BASIC_MINUS_TOKEN
                JMP ROMAF0D
            IFE A, BASIC_PLUS_TOKEN
                JMP ROMAE8A
            IFN A, CBM_QUOTE ; quote mark
                JMP ROMAECC
            SET C, 0
            IFG A, CBM_QUOTE-1 ; carry over from 6502 CMP above
                SET C, 1 
; remember to set C before jumping here.
; this entry point consumes a string in quotes.
:STRTXT
:ROMAEBD    SET A, [RAM7A]
            ADD A, C
            JSR STRLIT
            SET [RAM7A], [RAM71] ; move cursor to after string
            RTS
            ;not a digit, variable, pi, string, or */-
:ROMAECC    IFN A, BASIC_NOT_TOKEN
                JMP ROMAEE3
            SET Y, TBL_OP_NOT-TBL_OP ; vector into TBL_OP
            JMP ROMAF0F

; NOT operator (actually XORs all bits)
:NOTOP
:ROMAED4    JSR AYINT 
            SET A, [FACHO+1]
            XOR A, -1
            JMP GIVAYF

; get operand

:ROMAEE3    IFE A, BASIC_FN_TOKEN ; FN
                JMP FNDOER
:ROMAEEA    IFG A, 0xB3 ; Token for a function or operator 
                JMP ISFUN

; ----------------------------------------------------------------------------
; EVALUATE "(EXPRESSION)"
; ----------------------------------------------------------------------------

:PARCHK
:ROMAEF1    JSR CHKOPN
            JSR FRMEVAL
            ; Fall through to CHKCLS

; CHECK for the appropriate punctuation,
; and skip it.
:CHKCLS
:ROMAEF7    SET A, 0x29  ; close paren
            JMP SYNCHR
:CHKOPN
:ROMAEFA    SET A, 0x28  ; open paren
            JMP SYNCHR
:CHKCOM
:ROMAEFD    SET A, CBM_COMMA
; Next non-whitespace character should be A,
; otherwise it's a syntax error.
:SYNCHR
:ROMAEFF    SET Y, [RAM7A]
            IFE [Y], A
                JMP CHRGET
:SNERR ; ?SYNTAX  ERROR
:ROMAF08    IFE DEBUG_SNERR, 1
                JSR PRINT_EXPECTED
            SET X, 0x0B ; 
            JMP ERROR

:SN_EXPECTED    DAT 0
:SN_GOT         DAT 0
; new feature: prints the character it was expecting
:PRINT_EXPECTED
        SET [SN_EXPECTED], A
        SET [SN_GOT], [Y]
        SET A, EXPECTED_MSG
        JSR STROUT
        SET A, [SN_EXPECTED]
        JSR CHROUT
        SET A, GOT_MSG
        JSR STROUT
        SET A, [SN_GOT]
        IFE A, 0
            JMP SN_GOT_NULL
        JMP CHROUT
:SN_GOT_NULL
        SET A, NULL_MSG
        JMP STROUT
                
:EXPECTED_MSG
    DAT 13,"EXPECTED ", 0
:GOT_MSG
    DAT ", GOT ", 0
:NULL_MSG
    DAT "NULL", 0

; RECURSIVE get value

:ROMAF0D    SET Y, TBL_OP_NEG-TBL_OP ; vector into TBL_OP
:ROMAF0F    SET A, POP  ; discard
            JMP ROMADFA

; Check variable pointer range
; I think it uses a hard-coded top of RAM?
; so I guess I'll do the same.
:ROMAF14    SET A, [RAM64]
            SUB A, BASICMEMEND
            IFE EX, -1  ; underflow
                JMP ROMAF27
            SET A, ROME3A2 ; what is this?
            SUB A, [RAM64]
:ROMAF27    SET C, EX ; set C registor to what
            ADD C, 1 ; 6502 carry bit would have been
            RTS
            
; Get value of variable for EVAL
:ROMAF28    JSR PTRGET  ; get pointer in I
:ISVAR
:ROMAF2B    SET [RAM64], I
            SET X, [VARNAM]
            SET Y, [VARNAM+1]
            IFE [VALTYP], 0
                JMP ROMAF5D
            SET [FACOV], 0
            JSR ROMAF14 ; check VARPNT range?
            ; If not found
:ROMAF3E    IFE C, 0
                RTS
:ROMAF40    ; TODO: Check for TI$
            RTS
            
:ROMAF5C    RTS

:ROMAF5D    IFC [INTFLG], 0x80 
                JMP ROMAF6E
            SET A, [RAM64]  ; get pointer to integer
            SET A, [A]      ; follow pointer
            JMP GIVAYF

:ROMAF6E    JSR ROMAF14  ; check variable pointer range?
            IFE C, 0 ; Not found?
                JMP ROMAFA0
            ; TODO: check for TI and ST
            JMP ROMAFA0
            ; First character of numeric variable
            ; wasn't T, but maybe it's S?
; continue of get value of variable
:ROMAF92    IFN X, 0x53  ; S
                JMP ROMAFA0
            IFN Y, 0x54  ; T
                JMP ROMAFA0
            JSR ROMFFB7  ; get status
            JMP ROMBC3C  ; convert A to float
:ROMAFA0    SET A, [RAM64]
            JMP MOVFM

:ISFUN   ; is a basic function?
:ROMAFA7    SET PUSH, A ; originally *2
            SET X, A
            JSR CHRGET
            IFL X, BASIC_LEFT_TOKEN ; LEFT$ token
                JMP ROMAFD1
            ; handle two-argument functions (LEFT$ etc)
            JSR CHKOPN
            JSR FRMEVAL
            JSR CHKCOM
            JSR CHKSTR ; check value is string
            SET X, POP
            SET PUSH, [RAM64]
            SET PUSH, X
            JSR GETBYT  ; get small integer
            SET Y, POP
            SET A, X
            SET PUSH, A
            JMP ROMAFD6
            ; handle single-argument functions
:ROMAFD1    JSR PARCHK ; evaluate between parens
            SET Y, POP
            SET A, Y ; DEBUG
            SET B, FUNCTION_VECTOR ; DEBUG
            SET C, FUNCTION_ROUTINES
:ROMAFD6    ADD Y, FUNCTION_VECTOR
            JSR [Y]
            JMP CHKNUM ; check return is numeric

; OR/AND operators

:OROP       SET Y, -1
            IFN Y, -1 ; skip next
:ANDOP      SET Y, 0
            SET [RAM0B], Y
            JSR AYINT    ; float to integer
            SET A, [RAM64]
            XOR A, [RAM0B]
            SET [CHARAC], A
            JSR MOVFA
            JSR AYINT
            SET A, [RAM64]
            XOR A, [RAM0B]
            AND A, [CHARAC]
            XOR A, [RAM0B]
            JMP GIVAYF
                

; get time in float accu
:ROMAF84    JSR ROMFFDE
            ; STX $64
            ; STY $63
            ; STA $65
            ; LDY #0
            ; STA $62
            RTS

; comparison operators...
; [VALTYP] refers to the type of the right-hand side
; C should refer to the type of the left-hand side
:RELOPS
:ROMB016    JSR CHKVAL ; make sure VALTYP matches C.
            IFN C, 0   ; string
                JMP STRCMP
            SET A, [ARGSGN]
            BOR A, 0x7FFF
            AND A, [ARGHO]
            SET [ARGHO], A
            SET A, ARGEXP  ; pass pointer to FCOMP
            JSR FCOMP
            SET X, A
            JMP NUMCMP

:STRCMP     ; string compare (incomplete)
:ROMB02E    SET [VALTYP], 0 ; result is numeric
            SUB [RAM4D], 1
            JSR ROMB6A6  ; get string length and address
            SET [RAM61], A  ; store string1 length
            SET [RAM62], X  ; store string1 address
            SET A, [RAM6C]
:ROMB041    JSR FRETMP ; allocate string memory
            SET [RAM6C], X ; store string2 address
            SET X, A       ; store string2 length
            SUB A, [RAM61] ; compare lengths
            IFE A, 0       ; same length
                JMP ROMB056
            SET A, 1       
            IFE EX, -1     ; different length
                JMP ROMB056
            SET X, [RAM61] ; Only compare letters in common
            SET A, -1
:ROMB056    SET [FACSGN], A ; This value will be returned
                            ; if all characters match.
            ; Compare each character
            SET I, [RAM6C]
            SET J, [RAM62]
            ADD X, 1
:ROMB05B    SUB X, 1
            IFN X, 0  
                JMP ROMB066 ; compare additional character
            ; compared all characters, set result
            SET X, [FACSGN] ; to whichever string is longer
:NUMCMP  ; numeric compare (first draft)
:ROMB061    SET I, [ARGHO+1]  ; ($6C),Y
            SET J, [FACHO]  ; ($62),Y
            IFU X, 0 ; BMI
                JMP ROMB072
            SET C, 0
            JMP CMPDONE
:ROMB066    SET A, [I]
            STI B, [J]
            IFE A, B        ; match
                JMP ROMB05B ; next character
            SET X, 1
            IFG A, B
                SET X, -1

:CMPDONE    ; X is -1, 0, or 1
:ROMB072    SET A, X
            ADD A, 1
            shl A, 1
            IFE A, 0
                BOR A, 1
            ; A is 1, 2, or 4, respectively
            AND A, [RAM12]   ; comparison
            IFN A, 0
                SET A, -1
            JMP ROMBC3C   ; convert A to float

:ROMB07E    JSR CHKCOM 
:STMT_DIM   SET [DIMFLG], A  ; DIMFLG to non-zero
            JSR PTRGET3
            JSR CHRGOT
            IF_NOT_NEXT_STMT
                JMP ROMB07E
            RTS
            

;get name and pointer to a variable.
; At the end, the cursor should be at the last character of 
; the variable name.
; Returns pointer in I (originally AY)
:PTRGET
:ROMB08B    JSR CHRGOT
:ROMB090    SET [DIMFLG], 0
:PTRGET3
:ROMB092    SET [VARNAM], A ; store first letter of variable
            ; throw SYNTAX if first character is not a letter.
            JSR CHRGOT
            JSR ISALPHA
            IFE C, 0
                JMP SNERR
            SET X, 0
:ROMB09F    SET [VALTYP], 0  ; numeric
            SET [INTFLG], 0
            JSR CHRGET
            IF_IS_DIGIT
                JMP ROMB0AF
            JSR ISALPHA
            IFE C, 0 ; not alpha
                JMP ROMB0BA
:ROMB0AF    SET X, A
            ; only first two characters count
            ; discard the rest of the variable name
:ROMB0B0    JSR CHRGET
            IF_IS_DIGIT
                JMP ROMB0B0
            JSR ISALPHA
            IFE C, 1 ; is alpha
                JMP ROMB0B0
:ROMB0BA    ; consumed entire name of variable
            ; look for sigil at the end
            IFN A, 0x24 ; $ for string
                JMP ROMB0C4
            SET [VALTYP], -1  ; string
            JMP ROMB0D4
:ROMB0C4    IFN A, 0x25 ; % for integer
                JMP ROMB0DB
            IFN [SUBFLG], 0
                JMP ROMAF08 ; throw error if subscripts not allowed
            SET [INTFLG], 0x80
            BOR [VARNAM], 0x80
:ROMB0D4    BOR X, 0x80
            JSR CHRGET
:ROMB0DB    SET [VARNAM+1], X
            BOR A, [SUBFLG]
            SUB A, 0x28 ; left paren
            IFE A, 0
                JMP ISARY
:ROMB0E7    SET [SUBFLG], 0
            SET I, [VARTAB]  ; pointer
            SET A, [VARNAM]    ; first char of cariable
            SET B, [VARNAM+1]  ; 2nd char of variable
:ROMB0F3    SET [LOWTR], I
            IFE I, [ARYTAB] ; end of table?
                JMP NOTFNS         ; Create a variable
            IFE A, [I]
                IFE B, [I+1]
                    JMP OTHERB185  ; return pointer
:ROMB109    ADD I, 5 ; move pointer to next entry
            JMP ROMB0F3

:OTHERB185  ADD I, 2 ; skip past name to contents
            SET [VARPNT], I
            RTS         

            
; set C=1 if character in A is alphabetic
; might be slightly faster if we converted this
; to use the DCPU-16 EX register.
:ISALPHA
:ROMB113    SET C, 1
            IFL A, 0x41 ; A
                SET C, 0
            IFG A, 0x5B ; Z
                SET C, 0
            RTS
; the NOTFNS routine points here when there's an array,
; but there's nothing special there
:C_ZERO
:ROMBF13    DAT 0,0

:NOTFNS ; Create a new BASIC variable
; VARIABLE POINTERS ARE 5 WORDS INSTEAD OF 7 BYTES
:ROMB11D    IFN PEEK, 0x2A ; Array?
                JMP ROMB128
            ; i am stumped as of now
:ROMB123    SET I, C_ZERO ; ?
            RTS
:ROMB128    SET A, [VARNAM]
            SET Y, [VARNAM+1]
            IFN A, 0x54 ; T
                JMP ROMB13B
            IFE Y, 0xC9 ; I$
                JMP ROMB123
            IFE Y, 0x49 ; I
                JMP ROMAF08 ; can't set TI
:ROMB13B    IFN A, 0x53 ; S
                JMP ROMB143
            IFE Y, 0x54 ; T
                JMP ROMAF08
:ROMB143    SET [LOWTR], [ARYTAB] ; start of source
            SET A, [STREND] ; end of all variables
            SET [HIGHTR], A  ; end of source
            ADD A, 5        ; room for one variable
            SET [HIGHDS], A ; end of destination
            JSR BLTU
            ; move array table up
            ADD [ARYTAB], 5
            SET I, [LOWTR]
            ; bytes 1&2: name
            STI [I], [VARNAM]
            STI [I], [VARNAM+1]
            ; bytes 3-5 depend on type
            STI [I], 0
            STI [I], 0
            STI [I], 0
; Variable found 
:FINPTR
:ROMB185    SUB I, 3 ; set pointer to right after name
            SET [VARPNT], I
            RTS         
; absolutely nothing goes wrong assigning the first variable
; the second variable screws up everything
            

; ----------------------------------------------------------------------------
; COMPUTE ADDRESS OF FIRST VALUE IN ARRAY
; was: ARYPNT = (LOWTR) + #DIMS*2 + 5   (5 = 2 + 2 + 1)
; now: ARYPNT = A + #DIMS + 4  
; ----------------------------------------------------------------------------
:GETARY
:ROMB194    SET [LOWTR], A
            SET B, [COUNT]
            ADD B, 4
            ADD B, A
            SET [HIGHDS], B  ; End of destination
            RTS

:N32768
:ROMB1A5    DAT 0x90, 0x8000, 0x0000

; routine to convert float to fixed point
:ROMB1AA    JSR AYINT
            SET A, [FACHO+1]
            RTS

:INTIDX ; Convert floating point subscript
        ; to a positive integer
:ROMB1B2    JSR CHRGET
:ROMB1B5    JSR FRMEVAL
:MKINT
:ROMB1B8    JSR CHKNUM  ; check that term is numeric
            IFG [FACSGN], 0x7F  ; check that it is positive
                JMP FCERR
; convert float to integer
:AYINT
:ROMB1BF    IFL [FACEXP], 0x90
                JMP QINT
            SET A, N32768 ; -32768
            JSR FCOMP
:ROMB1CC    IFU A, 0    ; less than -32768
                JMP FCERR ; Illegal Quantity
            JMP QINT

;Find Array Element or Create New Array in RAM
;
;This routine searches for an array.  If it is found, the subscript
;value is checked to see if it is valid, and pointers to the array and
;element of the array are set.  If it is not found, the array is
;created, and the pointers set.
:ISARY
:ROMB1D1    SET A, [DIMFLG]
            BOR A, [INTFLG]
            SET PUSH, A
            SET PUSH, [VALTYP]
            SET Y, 0
:ROMB1DB    SET PUSH, Y  ; push... subscript?
            SET PUSH, [VARNAM]
            SET PUSH, [VARNAM+1]
            JSR INTIDX ; get subscript
            SET [VARNAM+1], POP
            SET [VARNAM], POP
            SET Y, POP
            ; insert address 2 back in stack
:ROMB1EE    SET B, PEEK
            SET C, PICK 1
            SET PUSH, B
            SET PICK 1, C
            SET PICK 2, [RAM64]
            ADD Y, 1 ; Increase dimension
            JSR CHRGOT
            IFE A, CBM_COMMA
                JMP ROMB1DB
            SET [COUNT], Y
            JSR CHKCLS
            SET [VALTYP], POP
            SET A, POP
            SET [INTFLG], A
            AND A, 0x7F
            SET [DIMFLG], A
; ----------------------------------------------------------------------------
; SEARCH ARRAY TABLE FOR THIS ARRAY NAME
; ----------------------------------------------------------------------------
            SET A, [ARYTAB]
:ROMB21C    ; checked all arrays yet?
            IFE A, [STREND]
                JMP MAKE_NEW_ARRAY
            SET Y, A
            ; check for name match
            IFE [VARNAM], [Y]
                IFE [VARNAM+1], [Y+1]
                    JMP USE_OLD_ARRAY
            SET A, [Y+2]  ; get size of current item
            ADD A, Y      ; derive location of next item
            JMP ROMB21C
            

:BSERR
:ROMB245    SET X, 0x12 ; ?BAD SUBSCRIPT
            JMP ERROR
:FCERR
:ROMB248    SET X, 0x0E ; ?ILLEGAL QUANTITY
            JMP ERROR

; ----------------------------------------------------------------------------
; FOUND THE ARRAY
; ----------------------------------------------------------------------------
:USE_OLD_ARRAY
:ROMB24D    SET X, 0x13 ; ?REDIM'D ARRAY
            IFN [DIMFLG], 0
                JMP ERROR
            JSR GETARY
:ROMB256    SET A, [COUNT] ; number of dimensions in sought array
            SET Y, [LOWTR] ; pointer to found array
            IFN A, [Y+3]   ; number of dimensions in found array
                JMP BSERR
            SET A, [COUNT]
            JMP FIND_ARRAY_ELEMENT

; allocate array
; pre: if DIM, each dimension should be on the stack, and
;      the number of dimensions in [COUNT].
;      regardless, VARNAM should have the array name.
; array data structure:
; 2 words for name
; 1 word for size 
; 1 word for number of dimensions
; for each dimension, 1 word for the size of that dimension
; then the variable values:
.DEFINE SIZEOF_INT, 1
.DEFINE SIZEOF_STR, 2
.DEFINE SIZEOF_FLOAT, 3
:MAKE_NEW_ARRAY
:ROMB261    JSR GETARY
            JSR REASON
            SET Y, [LOWTR]
            SET X, SIZEOF_FLOAT
            SET A, [VARNAM]
            SET [Y], A
            IFB A, 0x80 ; first type bit set
                SUB X, SIZEOF_FLOAT-SIZEOF_STR
            SET A, [VARNAM+1]
            SET [Y+1], A
            IFB A, 0x80 ; both type bits set (can't dim functions)
                SUB X, SIZEOF_STR-SIZEOF_INT
            SET [RAM71], X
            ADD Y, 3
            SET [Y], [COUNT]  ; number of dimensions
            SET X, 11 ; default array size for ad-hoc usage
:ROMB286    ADD Y, 1
            IFC [DIMFLG], 0x40  ; if no DIM statement,
                JMP ROMB296      ; then always one-dimensional
            SET X, POP     ; pop dimension
            ADD X, 1       ; add one so that we can use 0 too 
:ROMB296    SET [Y], X
            MUL [RAM71], X  ; multiply byte count by this dimension.
            IFN EX, 0 ; result >64K
               JMP OMERR
            SUB [COUNT], 1
            IFN [COUNT], 0
                JMP ROMB286  ; next dimension
            SET X, [HIGHDS]
            ADD X, [RAM71]
            IFN EX, 0
                JMP OMERR
            ADD Y, 1
:L30BD
            SET A, Y
            ADD A, [RAM71]  ; might be too far?
            JSR REASON
            ; memory is allocated
            SET [STREND], A
            ; put size of memory block in the array
            ; can't make a direct pointer because this
            ; memory gets moved around a lot.
            SUB A, [LOWTR]
            SET Y, [LOWTR]
            SET [Y+2], A
            ; blank out the array elements
            SET I, [STREND] ; end of memory
            SET J, [RAM71]  ; number of bytes in elements
            SUB I, 1
            ; blank out the array elements
:ARRAYZEROLOOP
            STD [I], 0
            IFN J, 0
                JMP ARRAYZEROLOOP            
            IFN [DIMFLG], 0
                RTS  ; DIM'd the array, don't need to access it.
            ADD Y, 1
            SET [LOWTR], Y                  
; compute reference to array element
; [LOWTR+3] POINTS AT # OF DIMS IN ARRAY DESCRIPTOR
; THE SUBSCRIPTS ARE ALL ON THE STACK AS INTEGERS
; HIGHDS must have been set by GETARY.
; todo: try replacing RAM71 references with a register
:FIND_ARRAY_ELEMENT
:ROMB2EA    SET I, [LOWTR]
            ADD I, 3
            SET [COUNT], [I]
            SET [RAM71], 0
:ROMB2F2    ADD I, 1   ; point to next dimension
            SET A, POP ; requested index of current dimension
            SET [RAM64], A
            IFL A, [I]
                JMP ROMB30E
            JMP BSERR ; ?BAD SUBSCRIPT
:ROMB30B    JMP OMERR   ;?OUT OF MEMORY
:ROMB30E    IFE [RAM71], 0
                JMP ROMB320
            MUL [RAM71], [I]
:ROMB320    ADD [RAM71], A
            SUB [COUNT], 1
            IFN [COUNT], 0
                JMP ROMB2F2
            ; compute size of each element
            SET A, SIZEOF_FLOAT
            IFB [VARNAM], 0x80 ; first type bit set
                SUB A, SIZEOF_FLOAT-SIZEOF_STR
            IFB [VARNAM+1], 0x80 ; both type bits set (can't dim functions)
                SUB A, SIZEOF_STR-SIZEOF_INT
            MUL A, [RAM71]
            ADD I, A
            ADD I, 1
            SET [VARPNT], I
:ROMB34B    RTS

; fre(0)
:ROMB37D    IFN [VALTYP], 0
                JSR ROMB6A6  
            JSR GARBAG
            SET A, [FREETOP]
            SUB A, [STREND]
            JSR GIVAYF
            IFE [FACSGN], 0
                RTS
            ; make it unsigned by adding 65536
            ; the answer may be >32768.
            SET A, P65536
            JMP FADD
:P65536     DAT 0x91, 0, 0


; throw ?ILLEGAL DIRECT if not in direct mode
:ERRDIR
:ROMB3A6    IFL [CURLIN], 0xFF00
                RTS
            SET X, 0x15 ; ILLEGAL DIRECT
            IFN X, 0x15 ; skip next
:ROMB3AE    SET X, 0x1B ; UNDEF'D FUNCTION
                JMP ERROR

:STMT_DEF
			JSR FNC  ; set DEFPNT to function variable
			JSR ERRDIR
			JSR CHKOPN
			SET [SUBFLG], 0x80
			JSR PTRGET
			JSR CHKNUM
			JSR CHKCLS
			SET A, BASIC_EQ_TOKEN
			JSR SYNCHR
			; push function definition
			SET PUSH, 0
			SET PUSH, [VARPNT] ; Pointer to argument variable
            SET PUSH, [RAM7A]  ; Pointer to function definition
            JSR DATAN
            SET [RAM7A], I
            SET I, [DEFPNT]
            JMP L3250  ; pop and store function definition
; get function name
:FNC
:ROMB3E1    SET A, BASIC_FN_TOKEN ;FN
            JSR SYNCHR
            BOR A, 0x80
            SET [SUBFLG], A
            JSR PTRGET3 ; within PTRGET.
            SET [DEFPNT], I
            JMP CHKNUM ; check that term is numeric
            ;and return
            
; expand FN call
:FNDOER
:ROMB3F4    JSR FNC
			SET PUSH, [DEFPNT]
			JSR PARCHK
			JSR CHKNUM
			SET Y, POP   ; got variable name
			SET [DEFPNT], Y
			SET X, [Y+1] ; get address of argument variable
			IFE X, 0
				JMP ROMB3AE ; UNDEF'D STATEMENT
            SET [VARPNT], X
            ; Push original value of arg variable
            SET PUSH, [X+2]
            SET PUSH, [X+1]
            SET PUSH, [X]
            ; Push current text cursor location
            SET PUSH, [RAM7A]
            SET [RAM7A], [Y]    ; move cursor to function definition
			; Move argument value to argument variable
            JSR STORE_FAC_AT_X_ROUNDED
            SET PUSH, [VARPNT]
            JSR FRMNUM
            SET I, POP
            SET [DEFPNT], I
            JSR CHRGOT
            IFN Z, 1
            	JMP SNERR
            SET [RAM7A], POP
:L3250		STI [I], POP  ; originally 5 bytes
            STI [I], POP
            STI [I], POP
			RTS
:STRD
:ROMB465    JSR CHKNUM ; arg must be numeric
            SET Y, FLOATSTR-1
            JSR FOUT1   ; FOUT starting at Y
            SET A, POP  ; originally 2x PLA
:ROMB46F    SET A, FLOATSTR-1
            JMP STRLIT
            
; ----------------------------------------------------------------------------
; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
; ADDRESS IS IN RAM64 AND WHOSE LENGTH IS IN A-REG
; ----------------------------------------------------------------------------
:STRINI
:ROMB475    SET [DSCPNT], [RAM64]
; ----------------------------------------------------------------------------
; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
; ADDRESS IS IN X AND WHOSE LENGTH IS IN A-REG
; ----------------------------------------------------------------------------
:STRSPA
:ROMB47D    JSR GETSPA    ; Allocate Memory in A
            SET [RAM62], X  ; string address 
            SET [RAM61], A  ; string length
            RTS


; get description of string into a location
; on the temporary string stack.
; Pass: A as location of string.
;       [CHARAC] as ...
;       [ENDCHR] as the end character, 0x22 or 0x00.
; Returns: length, then address, stored to the
;          location pointed to by TEMPPT.
;          2 added to [TEMPPT]
; Should set [INDEX]
; stores length in [RAM61]
; stores address in [RAM62]
:STRLIT
:ROMB487    SET X, CBM_QUOTE ; quote
            SET [CHARAC], X
            SET [ENDCHR], X
; enter here if CHARAC and ENDCHR aren't quotes
:STRLT2
:ROMB48D    SET [RAM6F], A   ; String pointer
            SET [RAM62], A   ; String beginning pointer
            ; LOOP to...???
            SET I, [RAM6F]
            SUB I, 1

:ROMB497    ADD I, 1
:ROMB498    SET A, [I]         ; get character
            IFE A, 0
                JMP ROMB4A8
            IFE A, [CHARAC]    ; 
                JMP ROMB4A4
            IFN A, [ENDCHR]    ;
                JMP ROMB497
:ROMB4A4    
:ROMB4A8    
:ROMB4A9    SET Y, I         ; subtract original pointer
            SUB Y, [RAM6F]   ; to obtain the length
            IFE A, CBM_QUOTE 
                ADD I, 1     ; put end past trailing quote
            SET [RAM61], Y  ; Length in [RAM61]
            SET [RAM71], I  ;originally had to add Y to RAM6F
            ; oh wait this is a test on MSB of RAM6F
            SET A, [RAM6F]
            ; i think this bit here is set to treat
            ; stuff in the 200-2FF range different from
            ; stuff in the ROM range
:ROMB4B7    IFE [RAM6F], 0   ; test for whatever happens below B4D5.
                JMP ROMB4BF  ; it makes the memory copy unconditional
            IFG A, RAM0200+BASIC_BUFFER_LENGTH ; not immediate mode
                JMP PUTNEW  ; skip memory copy 
            IFU A, RAM0200
                JMP PUTNEW  ; skip memory copy
            ; if it's in the temporary string area,
            ; it needs to be moved into memory
:ROMB4BF    ; Y should have a string length now
            ; and RAM6F should be the start of source memory
            SET A, Y        ; send A as length
            JSR STRINI     ; send destination in [FRESPC]
            SET X, [RAM6F]  ; send source as X
            JSR MOVSTR     ; move string to [FRESPC]
; ----------------------------------------------------------------------------
; STORE DESCRIPTOR IN TEMPORARY DESCRIPTOR STACK
;
; THE DESCRIPTOR IS NOW IN FAC, FAC+1
; PUT ADDRESS OF TEMP DESCRIPTOR IN FAC+2,3
; ----------------------------------------------------------------------------
:PUTNEW
:ROMB4CA    IFU [TEMPPT], TEMPSTEND 
                JMP ROMB4D5 
            ; if no room on stack
:ROMB4D0    SET X, 0x19 ; ?FORMULA TOO COMPLEX
            JMP ERROR
:ROMB4D5    SET I, [TEMPPT] ; current pointer location
            SET [LASTPT], I
            SET [RAM64], I    ; Pointer to pointer 
            STI [I], [RAM61]    ; Length  I++
            SET [I], [RAM62]    ; Pointer
            SET [FACOV], 0 ; literal translation
            SET [RAM6F], 0 ; probably meant to do this
            STI [VALTYP], -1 ; string     I++
            SET [TEMPPT], I  ; originally I+2
            RTS
;
:STRDEBUG
            ;SET A, [TEMPPT]
            ;SET B, TEMPST
            ;SET C, TEMPSTEND
            ;SET X, [FACEXP]
            ;SET Y, [FACHO]
            SET B, [RAM7A]
            DAT 0x3400
            RTS



; allocate number of bytes in A
; The amount of space needed for a string is 
; passed to this routine, and the routine checks 
; if there is that amount of space available in free
; memory. If not, it does a garbage collection and 
; tries again.
; Returns original length requested in A
; Returns address in X (originally XY)
; Single string ptr -- includes variable name and extra byte.
.DEFINE GARB_LG, 5
; Array pointer -- contains only length and address
.DEFINE GARB_SM, 2
; The first time through, I was under the impression that
; the C64 version cached a lot of zero-page memory, but I
; can't seem to find the code that did that.  So I'll just
; re-use the variables in the same way, which is probably
; important since they serve as parameters to BLTU.
; ----------------------------------------------------------------------------
; MAKE SPACE FOR STRING AT BOTTOM OF STRING SPACE
; (A)=# BYTES SPACE TO MAKE
;
; RETURN WITH (A) SAME,
;   AND FRESPC = X = ADDRESS OF SPACE ALLOCATED
; ----------------------------------------------------------------------------
:GETSPA
:ROMB4F4    SHR [GARBFL], 1
:ROMB4F6    ;WARNING: potential for off-by-one error here
            SET X, [FREETOP] ; pointer to end of free RAM
            SUB X, A         ; subtract length of string
            IFL X, [STREND]  ; compare with start of free RAM
                JMP ROMB516
            SET [FREETOP], X ; allocate free RAM
            SET [FRESPC], X ; temporary space for strings
            ; A still contains the length 
            RTS
:L3311            
:ROMB516    SET X, 0x10    ; ?OUT OF MEMORY ERROR
            IFG [GARBFL], 0x7f
                JSR GARBAG
            SET [GARBFL], 0x80
            JMP ROMB4F6
; ----------------------------------------------------------------------------
; SHOVE ALL REFERENCED STRINGS AS HIGH AS POSSIBLE
; IN MEMORY (AGAINST HIMEM), FREEING UP SPACE
; BELOW STRING AREA DOWN TO STREND.
; ----------------------------------------------------------------------------
:GARBAG
:ROMB526    SET I, [MEMSIZ]
:FINDHIGHESTSTRING
:ROMB52A    SET [FREETOP], I
            SET [DEFPNT], 0
; LOWTR will be set to the highest string variable that is
; actually referenced somewhere in the program.
            SET [LOWTR], [STREND]
; check all temporary string pointers
            SET I, TEMPST   ; pointer to string stack
:ROMB544    IFE I, [TEMPPT]
                JMP ROMB54D
            JSR CHECK_VARIABLE
            JMP ROMB544 ; compare next I
; check all scalar string pointers
:ROMB54D    SET [DSCLEN], GARB_LG  ; bytes per variable
            SET I, [VARTAB]
:ROMB559    IFE [ARYTAB], I
                JMP ROMB566
            JSR CHECK_SIMPLE_VARIABLE
            JMP ROMB559 ; compare next I
; check all array string pointers
:ROMB566    SET [HIGHDS], I
            SET [DSCLEN], GARB_SM ; number of bytes
:ROMB56E    SET I, [HIGHDS]
:ROMB572    IFE [STREND], I
                JMP MOVE_HIGHEST_STRING_TO_TOP
:ROMB57D    SET [INDEX], I ; probably just need to cache
:ROMB581    ADD [HIGHDS], [I+2] ; add array size in bytes
            ; HIGHDS now points to next array
            IFC [I], 0x80
                JMP ROMB56E   ; Not a string, go to next array
            IFB [I+1], 0x80
                JMP ROMB56E   ; Not a string, go to next array
            ; get string array
            ADD I, 3   ; I now points to number of dimensions
            ADD I, [I] ; Add number of dimensions
            ;Loop through all string pointers here.
:ROMB5B0    IFE I, [HIGHDS] ; reached end of array?
                JMP ROMB572 ; go to next array
:ROMB5B8    JSR CHECK_VARIABLE
            JMP ROMB5B0
                
; ----------------------------------------------------------------------------
; PROCESS A SIMPLE VARIABLE
; ----------------------------------------------------------------------------
:CHECK_SIMPLE_VARIABLE
:ROMB5BD    SET A, [I]
            SET B, [I+1]
            ; check type bits in the name.
            IFB [I], 0x80  
                JMP CHECK_BUMP ; not a string; skip.
            IFC [I+1], 0x80 
                JMP CHECK_BUMP ; not a string, skip.
            SET Y, I
            ADD Y, 2 ; set Y to pointer after name.
            IFE Y, 0 ; skip default Y in next instruction
; ----------------------------------------------------------------------------
; IF STRING IS NOT EMPTY, CHECK IF IT IS HIGHEST
; ----------------------------------------------------------------------------
; pass address of string desriptor in I? 
; This needs to return I
:CHECK_VARIABLE
:ROMB5C7    SET Y, I
            IFE [Y], 0   ; If zero length
                JMP CHECK_BUMP ; skip
            SET A, [Y+1]   ; Get pointer to string data
            IFL A, [FREETOP]  ; if it's in the area being searched
                JMP ROMB5DC   ; then proceed
            JMP CHECK_BUMP    ; otherwise skip; it's already sorted
:ROMB5DC    IFG A, [LOWTR]
                JMP ROMB5E6
            JMP CHECK_BUMP
:ROMB5E6    SET [LOWTR], A
            SET [DEFPNT], I
            SET [RAM55], [DSCLEN]
; ----------------------------------------------------------------------------
; ADD (DSCLEN) TO PNTR IN I
; ----------------------------------------------------------------------------
:CHECK_BUMP
:ROMB5F6    ADD I, [DSCLEN]
:ROMB601    RTS

; ----------------------------------------------------------------------------
; FOUND HIGHEST NON-EMPTY STRING, SO MOVE IT
; TO TOP AND GO BACK FOR ANOTHER
; ----------------------------------------------------------------------------
:MOVE_HIGHEST_STRING_TO_TOP
:ROMB606    ;GARBDEBUG(0x0D) ; M for MOVE
            ; defpnt isn't getting set 
            IFE [DEFPNT], 0
                JMP ROMB601
            ;GARBDEBUG(0x21) ; ! for actually happening
            SET Y, [RAM55]  ; a cached DSCLEN
            SET I, [DEFPNT] ; contains the address of a descriptor
            IFE Y, GARB_LG  ; is a scalar
                ADD I, 2    ; point past the name
            SET [RAM55], I  ; hide link
            SET A, [I]      ; get length of string
            ADD A, [LOWTR]  ; index past LOWTR that far
            SET [HIGHTR], A         ; Source end + 1
            SET [HIGHDS], [FREETOP] ; Destination end + 1
            JSR BLTU2 ; copy memory, get next FREETOP in I.
            SET X, [RAM55]  ; recover index
            ADD X, 1        ; point to address
            SET [X], I      ; first byte of destimation
            JMP FINDHIGHESTSTRING

; JOINING STRINGS
:CAT
:ROMB63D    ; DEBUG STACK POINTER
            SET PUSH, [RAM64]
            JSR EVAL
            JSR CHKSTR ; check that value is string
            SET [RAM6F], POP
            SET Y, [RAM6F]
            SET A, [Y]  ; Get length of first string
            SET Y, [RAM64]
            ADD A, [Y]  ; Get length of second string
            IFL A, 0x100 ; TODO: make customizable
                JMP ROMB65D
            SET X, 0x17 ; ?STRING TOO LONG
            JMP ERROR
:ROMB65D    JSR STRINI ; allocate memory, store len/ptr in A/X
            JSR MOVINS  ; move string in [RAM6F] to temporary string
            SET A, [DSCPNT]
            JSR FRETMP ; set [INDEX] to [DSCPNT] then de-allocate 
            JSR MOVSTR1 ; copy that too.
            SET A, [RAM6F]
            JSR FRETMP ; set [INDEX] to [RAM6F] then de-allocate
            JSR PUTNEW ; save descriptor on stack
            JMP ROMADB8

; move string
; move string pointed to by RAM6F, into that pointed to by INDEX.
:MOVINS
:ROMB67A
            SET Y, [RAM6F]
            SET A, [Y]
            SET X, [Y+1]

; move string with length A,
; from [INDEX] or X to [FRESPC]
; if you jump to MOVSTR1, [INDEX] should already be set
:MOVSTR
:ROMB688    SET [INDEX], X
:MOVSTR1
:ROMB68C    SET I, [INDEX]  ; source
            IFE A, 0   ; zero length
                RTS    ; do nothing
            ADD I, A        ; source
            SET J, [FRESPC] ; destination
            SET C, J  
            SUB C, 1 ; loop end condition
            ADD J, A
            IFE A, 0
                JMP ROMB699
            STD A, A ; Starting at last character
:ROMB690    STD [J], [I]
            IFU C, J
                JMP ROMB690
:ROMB699    ADD [FRESPC], A ; set pointer to byte after string
            RTS

; returns an address in X
;    and a length in A
; ----------------------------------------------------------------------------
; IF (FAC) IS A TEMPORARY STRING, RELEASE DESCRIPTOR
; ----------------------------------------------------------------------------
:FRESTR
:ROMB6A3    JSR CHKSTR
; ----------------------------------------------------------------------------
; IF STRING DESCRIPTOR POINTED TO BY [RAM64] IS
; A TEMPORARY STRING, RELEASE IT.
; ----------------------------------------------------------------------------
:FREFAC
:ROMB6A6    SET A, [RAM64]
; ----------------------------------------------------------------------------
; IF STRING DESCRIPTOR WHOSE ADDRESS IS IN A IS
; A TEMPORARY STRING, RELEASE IT.
; ----------------------------------------------------------------------------
:FRETMP
:ROMB6AA    SET [INDEX], A
            JSR FRETMS   ; Move LASTPT to TEMPPT
            SET Y, [INDEX] ; though it's also in [INDEX]
            SET A, [Y]    ; length?
            SET X, [Y+1]  ; address?
            ; Don't deallocate if...
            IFE Z, 0  ; the original A wasn't LASTPT.
                JMP ROMB6D6
            IFN X, [FREETOP] ; the address isn't top of memory
                JMP ROMB6D6
            ; DEALLOCATE bytes
            ADD [FREETOP], A
            ; XY in original 6502
:ROMB6D6        SET [INDEX], X
:ROMB6DA        RTS

; ----------------------------------------------------------------------------
; RELEASE TEMPORARY DESCRIPTOR IF A = LASTPT
; ----------------------------------------------------------------------------
; If A is not found, set Z to 0
:FRETMS
:ROMB6DB    SET Z, 0
            IFN A, [LASTPT]
                RTS
            SET [TEMPPT], A
            SUB A, 2  ; size of a string pointer
            SET [LASTPT], A
            SET Z, 1
            SET Y, 0
            RTS
:CHRD
:ROMB6EC    JSR CONINT  ; get byte operand
            SET PUSH, X  ; push byte result
            SET A, 1
            JSR STRSPA   ; create a string 
            SET A, POP
            SET Y, [RAM62]  ; get address
            SET [Y], A      ; set ASCII value of only character
            SET A, POP
            JMP PUTNEW ; save descriptor in $61 on stack
:LEFTD
:ROMB700    JSR SUBSTRING_SETUP ; return Y as DSCPNT
            SET A, 0 ; left side
:ROMB706    IFL A, [Y]  
                JMP ROMB70C  ; 
            IFE A, [Y]  
                JMP ROMB70C  ; 
            ; if parameter is longer than length
            ; then return entire string
            SET X, [Y]
            SET A, 0
:ROMB70C    SET PUSH, A  ; push starting index
:ROMB70D    SET A, X
:ROMB70E    SET PUSH, A  ; push length
            JSR STRSPA   ; allocate number of bytes in A
            SET A, [DSCPNT] ; get address of descriptor
            JSR FRETMP   ; deallocate?
            ; returns A length and X dest address
            ; and dest address in [INDEX]
            SET A, POP  ; pop length
            ; originally only pulled one Y .  
            SET X, POP  ; pop offset
            ADD [INDEX], X
            JSR MOVSTR1 ; move string with length A
:ROMB729    JMP PUTNEW
:RIGHTD
:ROMB72D    JSR SUBSTRING_SETUP ; get parameters
            ; set starting index to string length
            ; minus the parameter
            SUB A, [Y]
            MUL A, -1
            JMP ROMB706
:MIDD
:ROMB737    SET [RAM64], -1 ; default: get all bytes
            JSR CHRGOT
            IFE A, 0x29 ; clos paren
                JMP ROMB748 ; default to end-of-string
            JSR CHKCOM
            JSR GETBYT ; length to extract in [RAM64]
:ROMB748    JSR SUBSTRING_SETUP ; Y=DSCPNT, A=index
			IFE A, 0  ; zero index requested
                JMP FCERR ; illegal quantity error
            SUB A, 1     ; convert 1-based index to 0-based offset
            SET PUSH, A
            SET X, 0
            STI I, [Y]  ; I <- [Y]+1 
            SUB A, I    ; SBC [[DSCPNT]]
            IFE EX, 0 ; if start index > real string length
                JMP ROMB70D 
            XOR A, -1 ; get number of characters left after index
            IFL A, [RAM64]     ; if fewer bytes left than requested 
                JMP ROMB70E
            SET A, [RAM64] 
            JMP ROMB70E

:ROMB39E    SET C, 1
            JSR PLOT
:ROMB3A2    SET A, 0
            JMP GIVAYF

; get first 2 parameters for LEFT$/RIGHT$/MID$
; returns A as numeric parameter
; returns Y as pointer to string descriptor
:SUBSTRING_SETUP
:ROMB761    JSR CHKCLS
            SET J, POP ; RTS address (was 2)
            SET A, POP ; discard - was 2
            SET A, POP ; first numeric parameter
            SET Y, POP ; pointer to string descriptor
            SET [DSCPNT], Y
            JMP J

; LEN function 
:ROMB77C    JSR GETSTR
            JMP GIVAYF

; ----------------------------------------------------------------------------
; IF LAST RESULT IS A TEMPORARY STRING, FREE IT
; MAKE VALTYP NUMERIC, RETURN LENGTH IN Y-REG
; ----------------------------------------------------------------------------
:GETSTR
:ROMB782    JSR FRESTR  ; get length in A
            SET [VALTYP], 0 ; returning a number
            SET Y, A     
            RTS

; ASC function
:ASCN
:ROMB78B    JSR GETSTR
            IFE A, 0
                JMP FCERR
            SET Y, [INDEX]
            SET A, [Y]
            JMP GIVAYF

; get an integer that fits into a byte
:GETBYTC
:ROMB79B    JSR CHRGET
:GETBYT
:ROMB79E    JSR FRMNUM  ; get formula in FAC
:CONINT     ; Convert FAC to integer and return as X
:ROMB7A1    JSR MKINT ; convert to integer
            SET X, [RAM64]
            JMP CHRGOT

:VAL
:ROMB7AD    JSR GETSTR
            IFE A, 0
                JMP ROMB7B5
            JMP ROMB8F7 ; zero FACEXP and FACSGN
:ROMB7B5    SET X, [RAM7A]
            SET [RAM71], X
            SET A, [INDEX]
            SET [RAM7A], A
            ADD X, A
            ; wait, did we just add two pointers?
            ; I need to examine what ROMB6A3 returns in [INDEX].
            DAT 0x2000
:ROMB7D7    JSR CHRGOT
            JSR FIN
            SET A, POP
            SET [J], 0
            ; move BASIC text cursor to end of string.
:ROMB7E2    SET [RAM7A], [RAM71]
            RTS

.include "poke.dasm16"

:ROME386
            SET X, 0x80
            JMP_IND IERROR ;normally E38B
:DEF_ERROR    
:ROME38B ; error message handler
            IFG X, 0x7F
                JMP READY
            JMP BASIC_ERROR
    
:ROME394  ; ** COLD START BASIC
            ;JSR ROME453 ; don't need to initialize vectors
            JSR INIT ; Initialize BASIC
            JSR ROME422 ; Print start-up messages
            SET SP, STACKBASEND
            JMP ROME386


:INIT
:ROME3BF
            SET A, 0x4C ; ? 
            SET [USRPOK], A
            SET [RAM0311], FCERR
            SET [RAM05], GIVAYF
            SET [RAM03], ROMB1AA
            ; skipped code that copies CHRGET/CHRGOT
            SET [DSCLEN], 2  ; single string descriptor
            SET [BITS], 0
            SET [CHANNL], 0
            SET [LASTPT], 0
            ; TODO: figure out why we're doing this
            ; with the stack
            ;SET [RAM01FD], 1
            ;SET [RAM01FC], 1
            SET [TEMPPT], TEMPST ; string stack to beginning
            SET C, 1
            SET B, 123
            JSR MEMBOT
            ; Set [TXTTAB] to beginning of BASIC area
            SET [TXTTAB], X
            SET B, 0xFFFF
            SET C, 1
            JSR MEMTOP
            SET [MEMSIZ], X
            SET [FREETOP], X
            SET Y, [TXTTAB]
            SET [Y], 0
            ADD [TXTTAB], 1
            RTS   ; 0x4B1?

    ; PRINT BASIC STARTUP MESSAGES
:ROME422
            SET A, [TXTTAB]
            JSR REASON
            SET A, ROME473  ; COMMODORE 64 BASIC V2
            JSR STROUT
            ; Calculate number of basic bytes free
            SET A, [MEMSIZ]
            SUB A, [TXTTAB]
            JSR LINPRT
            SET A, WORDS  ; BASIC BYTES FREE
            JSR STROUT
            ; prefill keyboard buffer with 
            JSR RUN_TEST_STRING
            ; go to READY prompt
            JMP SCRTCH  ; NEW statement.
            
; startup messages

:WORDS      DAT " BASIC BYTES FREE"
            DAT CBM_RETURN, 0
:ROME473    DAT CBM_CLR ;to clear the screen
            DAT 0x99 ; light green
            DAT "DCPU-16 BASIC "
            DAT 0x90 ; black
            DAT "ALPHA"
            DAT 0x9A ; light blue
            DAT CBM_RETURN
            DAT 0
:ROME4AC    DAT 0x81


; *** floating point package **

; TODO: isolate these memory locations from BASIC.
; this will be hard since some of them, especially
; FAC and ARG, are re-used for string pointers.
; It will also involve some if-not-defined directives
; to different error routines if BASIC isn't included.
;
; also TODO: optimize some of these routines so that
; they use registers instead of memory.
;
; dependencies in basic.dasm16:
;    ERROR
;    FCERR
;
:RAM5D 
:DECEXP DAT 0 ; decimal exponent during FIN/FOUT
:RAM5E  DAT 0 ; Number of digits during FIN?
:RAM60  DAT 0 ; sign of exponent operator in FIN
;
; Floating Point Accumulators
; 
:FAC1    ; Floating Point Accumulato0r 
:RAM61   ; Exponent (only 8 bits used)
:FACEXP DAT 0
:RAM62   ; Mantissa (32-bit)
:FACHO DAT 0
:RAM64 DAT 0
:FACOV  ;low order mantissa byte for rounding
:RAM70  DAT 0
:FACSGN
:RAM66 DAT 0

:RAM68 ; FAC Overflow during conversions
:BITS    DAT 0

:FAC2
:ARG     ; Floating Point Argument
:RAM69   ; Exponent (only 8 bits used)
:ARGEXP DAT 0
:RAM6A   ; Mantissa (32-bit)
:ARGHO  DAT 0
:RAM6C  DAT 0
:ARGOV
:RAM56  DAT 0
:ARGSGN
:RAM6E  DAT 0
:ARISGN ; Result of signed comparison
:SGNCPR
:RAM6F  DAT 0
;
; Multiplication result - denormalized.
:RESHO 
:RAM26  DAT 0
:RAM27  DAT 0, 0

:RAM67 
:SERLEN         ; Number of terms in a series evaluation
:SGNFLG  DAT 0  ; OR, a sign flag somewhere in FIN.

; Temporary registers
:FACTEMP1
:RAM57  DAT 0, 0, 0
:FACTEMP2
:RAM5C  DAT 0, 0, 0
:FACTEMP3
:RAM4E  DAT 0, 0, 0

:RNDX   ; random number seed
        DAT 0x80, 0x4FC7, 0x5258

:FADDH
:ROMB849
            SET A, CON_HALF
            JMP FADD
            
:FSUB
:ROMB850
            JSR CONUPK
:FSUBT
:ROMB853    SET A, [FACSGN]
            XOR A, -1
            SET [FACSGN], A
            XOR A, [ARGSGN]
            ASR A, 15
            SET [SGNCPR], A
            SET A, [FACEXP]
            JMP FADDT

:ROMB862    JSR SHIFT_RIGHT
            JMP ROMB8A3

;
;  FLOATING POINT ADDITION.
; should not destroy I, J.
;
:FADD
:ROMB867    JSR CONUPK ; read from pointer in A,
                        ; store to ARG.
:FADDT  ; Add FAC and ARG.  (load FACEXP in A first)
:ROMB86A    ; A = FACEXP
            IFE A, 0       ; 0 + ARG = ARG
                JMP COPY_ARG_TO_FAC  ; so return ARG.
            SET [ARGOV], [FACOV] 
            SET X, ARGEXP ;  pointer
            SET A, [X]    ; A = actual exponent
:FADD2
:ROMB877    IFE A, 0 ; FAC + O = FAC
                RTS  ; so return FAC
            SET Y, A
            SUB A, [FACEXP]  ; A = ARGEXP - FACEXP
            IFE A, 0         ; equal exponents
                JMP FADD3
            IFE EX, -1       ; subtraction underflow
                JMP ROMB893
:ROMB881    SET [FACEXP], Y ; Store larger exponent
            SET [FACSGN], [ARGSGN] 
            ;SET [BITS], 0  ; had to add this for some rsn
            XOR A, 0xFFFF
            ADD A, 1       ; ADC #$00 after a subtract
            SET [ARGOV], 0
            SET X, FACEXP ; a pointer to larger exponent
            JMP ROMB897
            ; enter here when carry clear
:ROMB893    SET [FACOV], 0
:ROMB897    IFU A, -7  ; Big exponent difference 
                JMP ROMB862 
                ;which does this:
                ;JSR SHIFT_RIGHT ; 
                ;JMP FADD3
            ; I think this is the number of bits
            ; to shift right, in negative 8-bit
            SET Y, A  
            SET A, [FACOV]
:ROMB89E    SHR [X+1], 1 ; shift mantissa to the right
            ;rotate 0-bit from the left
            JSR SHIFT_RIGHT4 ; Finish shifting right 
:FADD3      ; 84 a000 0000 - 84 bccc cccd
:ROMB8A3    IFA [SGNCPR], -1 ; result positive
                JMP FADD4 ; add mantissae and normalize
            ;subtract smaller mantissa and normalize
:ROMB8A7    ; set Y to the other accumulator
            SET Y, FACEXP
            IFN X, ARGEXP
                SET Y, ARGEXP
:ROMB8AF    SUB A, [ARGOV]
			SET [FACOV], A
            SET A, [Y+2]
            SBX A, [X+2]
            SET [FACHO+1], A
            SET A, [Y+1]
            SBX A, [X+1]
            SET [FACHO], A
            ; dcpu: 84 e333 3334 - 84 bccc cccd
; ----------------------------------------------------------------------------
; NORMALIZE VALUE IN FAC
; ----------------------------------------------------------------------------
:NORMALIZE_FAC1
:ROMB8D2    
			IFU EX, 0 ; one borrow left to do
                JSR COMPLEMENT_FAC
:NORMALIZE_FAC2
:ROMB8D7    SET Y, 0
:ROMB8D9    SET A, Y
:ROMB8DA    SET C, 0
:ROMB8DB    ; if highest 8 bits of mantissa are
            ; clear, we shift them left here.
            IFB [FACHO], 0xFF00   ; any bits set
                JMP NORMALIZE_FAC4  ; skip to single-bit
:ROMB8DF    SHL [FACHO], 8
            SHL [FACHO+1], 8
            BOR [FACHO], EX
            SHL [FACOV], 8
            BOR [FACHO+1], EX
            ;SHL Y, 8
            ;BOR [FACOV], Y
            ADD A, 8
            IFN A, 32  
                JMP ROMB8DB
        	; we've tried moving 32 bits  
            ; give up, return 0
:ZERO_FAC
:ROMB8F7    SET [FACEXP], 0
            SET [FACSGN], 0
            SET Z, 1
            RTS
:FADD4 ; add fractions then normalize 
; At this point the routine at B999 has
; brought the mantissa in ARGHO to the same
; exponent as FACHO, so we can add them here.
:ROMB8FE
            ADD A, [ARGOV]
            SET [FACOV], A
            ADX [FACHO+1], [ARGHO+1]
            ADX [FACHO], [ARGHO]
            
:ROMB91A    IFE EX, 0
                RTS
            JMP ROMB938 ; Increase exponent to make room
            
; postshift
:NORMALIZE_FAC3
:ROMB91D    ADD A, 1
            SHL [FACHO], 1
            SHL [FACHO+1], 1
            BOR [FACHO], EX
            SHL [FACOV], 1
            BOR [FACHO+1], EX
:NORMALIZE_FAC4
:ROMB929    IFC [FACHO], 0x8000   
                JMP ROMB91D
            ; mantissa is normalized
:ROMB92B    SUB A, [FACEXP]
            AND A, 0xFF
:ROMB92E    IFE EX, 0 ; no borrow involved
                JMP ZERO_FAC ; zero FACEXP and FACSGN, return
:ROMB930    XOR A, -1
            ADD A, 1
            AND A, 0xFF
:ROMB934    SET [FACEXP], A
:ROMB936    
            IFC A, 0xFF00 ; this BCC is probably unconditional
                RTS
    ; Add 1 to exponent, and 
    ; shift manitssa to the right by 1.
    ; this leaves the value as a whole unchanged.
    ; carry bit is always set
:ROMB938    ;SET C, EX
            ADD [FACEXP], 1
            IFG [FACEXP], 0xFF
                JMP OVERR
            SHR [FACOV], 1
            SHR [FACHO+1], 1
            BOR [FACOV], EX
            SHR [FACHO], 1
            BOR [FACHO+1], EX
            ;IFN C, 0
                BOR [FACHO], 0x8000
            RTS

:COMPLEMENT_FAC  ; replace FAC1 with its 2s-complement
:ROMB947    XOR [FACSGN], -1 
:COMPLEMENT_FAC_MANTISSA
:ROMB94D    XOR [FACHO], -1
            XOR [FACHO+1], -1
            XOR [FACOV], 0xFFFF
            ADD [FACOV], 0x0001
            ADX [FACHO+1], 0
            ADX [FACHO], 0
            RTS

; increment fraction  only
:ROMB96F    ADD [FACHO+1], 1
            ADX [FACHO], 0
            RTS

:OVERR ; Print overflow error message
:ROMB97E
            SET X, 0x0F
            JMP ERROR

   ; 01 too many files
   ; 02 file open
   ; 03 file not open
   ; 04 file not found
   ; 05 device not present
; debugging help
:OVERR1 ; too many files
	SET X, 1
	JMP ERROR
:OVERR2 ; file open
	SET X, 2
	JMP ERROR
:OVERR3 ; too many files
	SET X, 3
	JMP ERROR
:OVERR4 ; file open
	SET X, 4
	JMP ERROR
:OVERR5 ; file open
	SET X, 5
	JMP ERROR
:OVERR6 ; file open
	SET X, 6
	JMP ERROR
:OVERR7 ; file open
	SET X, 7
	JMP ERROR

; I think this routine inserts a byte at the beginning
; of the mantissa, using BITS as a high overflow byte.
:SHIFT_RIGHT1
:ROMB983   SET X, RESHO-1 ; RESHO has no exponent
            ; shift 8 bits from
           ; [BITS] -> mantissa -> [FACOV]
:SHIFT_RIGHT2
:ROMB985    SHR [FACOV], 8
            SHR [X+2], 8
            BOR [FACOV], EX
            SHR [X+1], 8
            BOR [X+2], EX
            ASR [BITS], 8
            BOR [X+1], EX
:SHIFT_RIGHT          
        ; set X to pointer to FACEXP or ARGEXP before calling here
        ; set A to the actual exponent therein
:ROMB999    ADD A, 8
:ROMB99B    IFB A, 0x80    ; BMI
                JMP SHIFT_RIGHT2 ; make 8 more high bits
            IFC A, 0xFF    ; BEQ with low 8 bits
                JMP SHIFT_RIGHT2
:ROMB99F    SUB A, 8  ; back to normal
            SET Y, A ; pass exponent to Y
:ROMB9A2    SET A, [FACOV]  ;FAC overflow
            IFC Y, 0x80 ; SBC #8 resulted in carry set
                JMP SHIFT_RIGHT5
:ROMB9A6    ASR [X+1], 1
            ; might jump here if X+1 is already shifted
; ----------------------------------------------------------------------------
; ENTER HERE FOR SHORT SHIFTS WITH NO SIGN EXTENSION
; ----------------------------------------------------------------------------
:SHIFT_RIGHT4
:ROMB9B0    SET C, EX
            SHR [X+2], 1          
:ROMB9B0A   BOR [X+2], C
:ROMB9B6    SET C, EX
            SHR A, 1   ; overflow byte
            BOR A, C   ; etc
            
:ROMB9B7    ADD Y, 1    ; add one to exponent diff
            IFB Y, 0x00FF  ; low bits not equal 0
                JMP ROMB9A6  ; do magic bits again
:SHIFT_RIGHT5
:ROMB9BA    SET C, 0
            SET EX, 0
            RTS  ; A contains 0x00 through 0xFF00
                    ; as fetched from FACOV?




                    
; FP constant ONE
; default STEP for FOR statement
:FONE
:ROMB9BC  DAT 0x81, 0, 0

:POLY_LOG
          DAT 0x03   ; degree 4
          DAT 0x7F,0x5E56,0xCB79
          DAT 0x80,0x139B,0x0B64
          DAT 0x80,0x7638,0x9316
          DAT 0x82,0x38AA,0x3B20


:CON_SQR_HALF
:ROMB9D6  DAT 0x80,0x3504,0xF334   ; 0,5 * SQR(2)
:CON_SQR_TWO
:ROMB9DB  DAT 0x81,0x3504,0xF334   ; SQR(2)
:CON_NEG_HALF
:ROMB9E0  DAT 0x80,0x8000,0x0000   ; -1/2
:CON_LOG_TWO
:ROMB9E5  DAT 0x80,0x3172,0x17F8   ; LOG(2)
:CON_INVSQRT
          DAT 0x5F, 0x3759, 0xDF00 ; magic number

; for double it's 0x5fe6eb50c7b537a9
; see http://www.lomont.org/Math/Papers/2003/InvSqrt.pdf

; FAC1 <- ln FAC1
:LOG
        JSR SIGN
        IFE A, 0   ;can't LOG(0)
            JMP FCERR
        SET A, [FACEXP]
        SUB A, 0x80
        SET PUSH, A  ; store log 2 of FAC
        SET [FACEXP], 0x80
        SET A, CON_SQR_HALF
        JSR FADD              ;BA01
        SET A, CON_SQR_TWO    ;BA04
        JSR FDIV              ;BA08
        SET A, FONE           ;BA0B
        JSR FSUB              ;BA0F
        SET A, POLY_LOG
        JSR POLYNOMIAL_ODD
        SET A, CON_NEG_HALF
        JSR FADD
        SET A, POP  ; retrieve log 2 of FAC
        JSR ADDACC  
        SET A, CON_LOG_TWO
        ; fall through to FMULT


; FAC1 <- FAC1 * FAC2
:FMULT
:ROMBA28    JSR CONUPK
; times operator
:FMULTT
:ROMBA2B    IFE A, 0  
                RTS ; anything times 0 = 0
            JSR ADD_EXPONENTS ; add exponents and handle signs
:ROMBA3D    SET A, [FACOV]
            JSR ROMBA59  ; multiply A and add to RESHO
            SET A, [FACHO+1]
            JSR ROMBA59  
            SET A, [FACHO]
            JSR ROMBA59
            JMP ROMBB8F  ; ???

            ; BYTE-SHIFT ADDER
:ROMBA59    SET [FACOV], [RESHO+1]
            SET [RESHO+1], [RESHO]
            SET [RESHO], 0
            SET Y, A
            MUL Y, [ARGHO]
            SET X, EX
            ADD [RESHO+1], Y
            ADX [RESHO], X
            SET Y, A
            MUL Y, [ARGHO+1]
            SET X, EX
            ADD [FACOV], Y
            ADX [RESHO+1], X
            ADX [RESHO], 0
            RTS

; move float indexed by AY into second float accu
; return FAC1's exponent in A to enable special
; zero-handling and a few shortcuts.
:CONUPK
:ROMBA8C    SET [INDEX], A
:ROMBA8CI   SET [ARGEXP], [A]
            SET B, [A+1]
            SET [ARGHO], B
            BOR [ARGHO], 0x8000 ; high bit is always 1
            ASR B, 15  ; pure 0 or -1
            SET [ARGSGN], B
            XOR B, [FACSGN]
            ASR B, 15   ; pure 0 or -1
            SET [SGNCPR], B
            SET [ARGHO+1], [A+2]
            SET A, [FACEXP]
            RTS
; Add exponents of ARG and FAC
; (called by FMULT and FDIV)
; also check for overflow and set result sign
:ADD_EXPONENTS
:ROMBAB7    SET A, [ARGEXP]
:ADD_EXPONENTS1
:ROMBAB9    IFE A, 0
                JMP ZERO ; pop return address and set FAC=0
            ADD A, [FACEXP]
            IFC A, 0x100 ; BCC
                JMP ROMBAC4
            IFB A, 0x80  ; BMI but carry set
                JMP OVERR
:ROMBAC2    AND A, 0xFF ; CLC
            JMP ROMBAC6  ; .BY $2C to jump next BPL 
:ROMBAC4    IFC A, 0x80 ; BPL
                JMP ZERO  ; return FAC=0
:ROMBAC6    ADD A, 0x80
            AND A, 0xFF
            SET [FACEXP], A
            IFE A, 0
                JMP ROMB8FB ; set FACSGN too and RTS.
            ; put comparison result into SGNCPR
:ROMBACF    SET [FACSGN], [SGNCPR]
:ROMBAD3    RTS
:ROMB8FB    SET [FACSGN], A
            RTS
; if FAC is positive, give OVERR
; if FAC is negative, set FAC=0, pop one return,
; and RTS.  called from EXP function
:OUTOFRNG
:ROMBAD4    SET A, [FACSGN]
            XOR A, -1
            IFU A, 0
                JMP OVERR
; pop return address and set FAC=0
:ZERO
:ROMBADA    SET A, POP ; don't return to FMULT/FDIV.
            JMP ZERO_FAC ; zero FACEXP and FACSGN

; This quick-multiplies FAC by 10 through bit shifting
; and addition.
:MUL10
:ROMBAE2    JSR COPY_FAC_TO_ARG_ROUNDED ; ARG = FAC
:ROMBAE5    IFE A, 0   ; (A is [FACEXP] now) 
                RTS ; 0 * 10 = 0
:ROMBAE9    ADD A, 2  ; ARG *= 4 by increasing exponent
            IFB A, 0x100
                JMP OVERR
:ROMBAED    SET [SGNCPR], 0
            JSR FADD2  ; FAC += ARG
            ADD [FACEXP], 1  ; FAC *= 2
            IFB [FACEXP], 0x100
                JMP OVERR
            RTS

; special case in FDIV, set result m=1
:MOV1HO
    SET [FACHO], 0x8000
    SET [FACHO+1], 0
    SET [FACOV], 0
    RTS

; reciprocal multiplier for 1/10 for parsing float literals
:DIV10
        SUB [FACEXP], 3 ; FAC <- FAC / 16
        JSR COPY_FAC_TO_ARG_ROUNDED       ; ARG = FAC
        SET [SGNCPR], 0
; reciprocal multiplier for 1/1.25 (5, 10, 20, etc)
:DIV125
        SET X, 0xCCCC
        JMP MULRPT      ; FAC <- ARG * 8/5

; reciprocal multiplier for 1/1.5 (3, 6, 12, etc)
:DIV15
        SET X, 0xAAAA
        JMP MULRPT      ; FAC <- ARG * 4/3
; optimized multiplier for repeating bytes
; accepts mantissa in X
:MULRPT
        SET A, [ARGHO]
        MUL A, X
        SET Y, EX
        SET [FACHO], Y
        ADD Y, A  ; carry bit one place to the right
        SET A, EX
        ADD [FACHO], A
        ADD Y, A ; carry bit to the infinite-right
        SET [FACHO+1], Y
        SET [FACOV], Y
        SET A, [ARGHO+1]
        IFN A, 0
           JMP MULRPT2 ; Multiply next word of ARG
        SET Y, A
        JMP MULRPT3 ; Add rounding bit and return.
:MULRPT2        ; Multiply ARGHO+1 by same thing
        MUL A, X
        SET Y, EX
        ADD [FACHO+1], Y
        ADX [FACHO], 0
        ADD Y, A ; carry bit one place to the right
        SET A, EX
        ADD [FACHO+1], A
        ADX [FACHO], 0
        ADD Y, A ; carry bit to the infinite-right
:MULRPT3        ; Add rounding bit
        SET EX, 1
        ADX [FACOV], Y
        ADX [FACHO+1], 0
        ADX [FACHO], 0
        JMP NORMALIZE_FAC2 ; normalize

; FAC <- FAC / ARG
:DIV
:ROMBB07    SET [SGNCPR], 0
            JSR MOVFM
            JMP FDIVT

; FAC <- ARG / FAC
:FDIV
:ROMBB0F    JSR CONUPK ; copy to ARG; should return exp in A
:FDIVT
:ROMBB12    IFE A, 0  ; dividing by 0?
                JMP ROMBB8A ; oh shi--
            JSR ROUND
            SET A, 0
            SUB A, [FACEXP]
            AND A, 0xFF
            SET [FACEXP], A
            JSR ADD_EXPONENTS ; add exponents
            ; works fine up to here
            ADD [FACEXP], 1
            IFC [FACEXP], 0xFF
                JMP OVERR
            ; special case
            SET X, [FACHO]
            SET Y, [ARGHO]
            ; if dividend and divisor have same mantissa,
            ; set result's mantissa to 1.0 and return
            IFE X, Y
                IFE [FACHO+1], [ARGHO+1]
                    JMP MOV1HO
            IFN [FACHO+1], 0 ; no chance of reciprocal shortcut
                JMP FDIVFULL
            ; m=0; copy mantissa
            IFE X, 0x8000
                IFE [FACHO+1], 0
                    JMP MOVFAHO
            ; Reciprocal dividers disabled; they're not
            ; accurate enough for fizzbuzz (though they're
            ; still used for decimal rendering)
            ; multiply by reciprocal for m=1.25 (5, 10, 20)
            IFE X, 0xA000
                JMP DIV125
            ;; multiply by reciprocal for m=1.5 (3, 6, 12)
            IFE X, 0xC000
                JMP DIV15
            ; all others, do a 16-bit integer divide.  This
            ; will hold us over until we can do this properly.  
            ; we can squeak out a few more bits of accuracy
            ; on a small divisor by denormalizing it.
:FDIVFULL
            SET [FACOV], 0
            ADD [FACEXP], 15
            IFB X, 0x00FF ; Top 8 bits clear
                JMP FDIVDEN1
            SHR X, 8
            SUB [FACEXP], 8
:FDIVDEN1
            IFB X, 1 ; Top bit clear
                JMP FDIVGO
:FDIVDEN2   SHR X, 1
            SUB [FACEXP], 1
            IFC X, 1
                JMP FDIVDEN2
:FDIVGO
            DIV Y, X    ; ARGHO = ARGHO / FACHO
            SET [FACHO+1], EX
            SET [FACHO], Y
            JMP NORMALIZE_FAC2

            SET X, EX   ; X = right of decimal point

            ; here's the original division routine, it started
            ; where the special case section is now.
            ; it was close to working
            SET X, RESHO-1 ; pointer, will be incremented before storage
            SET A, 1 ; "stop" bit -- when this 1 goes off the
                     ; left side of A, we store the byte to [X+1].
:ROMBB29    SET Y, [ARGHO]
            SUB Y, [FACHO]
            IFN Y, 0
                JMP ROMBB3F
            SET Y, [ARGHO+1]
            SUB Y, [FACHO+1]
            ;6502: Carry bit is set if ARGHO >= FACHO
            ; or if the shift-left at ROMBB4F
            ; resulted in an overflow
            ;DCPU: EX = -1 represents carry clear case
            ;      EX = 0 represents carry set case
:ROMBB3F    SET B, EX ; simulate PHP
            SHL A, 1  ; shifting part of ROL
            SET C, EX ; store carry bit off left side of A
            IFE B, 0
                BOR A, 1 ; carry-add part of ROL
            IFE C, 0 ; no bit fell off off left side
                JMP ROMBB4C
            ; the 1 that is in C is the guard bit we initially
            ; set in A. this means we have enoiugh bits in A
            ; to store a byte into RESHO now.
            ADD X, 1  
            SET [X], A
:FDIVTEST   ;SET B, [FACEXP]
            ;DAT 0x5800
            IFE X, RESHO+1
                JMP ROMBB7A  ; just do two more bits
            IFG X, RESHO+1
                JMP ROMBB7E  ; Store last two bits in [FACOV]
            SET A, 1 ; "stop" bit of next byte
:ROMBB4C    SET EX, B   ; pop ARGHO-FACHO compare again
:ROMBB4D    IFE EX, 0     ; ARGHO >= FACHO
                JMP ROMBB5D  ; Subtract FACHO from ARGHO
            ; subtract 1 at left of ARGHO and re-normalize.
:ROMBB4F    SHL [ARGHO], 1
            SET C, EX
            SHL [ARGHO+1], 1
            BOR [ARGHO], EX
            IFN C, 0 ; bit fell off left side of mantissa
                JMP ROMBB3F ; rotate A left too.
            IFN EX, 0 ; ARG is normalized
                JMP ROMBB29 ; go to beginning of compare loop
            JMP ROMBB3F
            ; originally BB5D preserved  A. 
:ROMBB5D    SUB [ARGHO+1], [FACHO+1]
            SBX [ARGHO], [FACHO]
            JMP ROMBB4F
:ROMBB7A    SET A, 0x4000 ; "stop" bit of FACOV
            JMP ROMBB4C
:ROMBB7E    SHL A, 14 ; originally 6
            SET [FACOV], A
            SET EX, B  ; PLP?
            JMP ROMBB8F
:ROMBB8A    SET X, 0x14  ; OH SHI--
            JMP ERROR
:ROMBB8F    SET [FACHO], [RESHO]
            SET [FACHO+1], [RESHO+1]
            JMP NORMALIZE_FAC2 ; normalize before returning
            
    

; Move a FP number from memory pointer in A to FAC1
:MOVFM
:ROMBBA2    SET [FACEXP], [A]
            SET Y, [A+1]
            SET [FACHO], Y
            SET [FACHO+1], [A+2]
            ASR Y, 15
            SET [FACSGN], Y
            BOR [FACHO], 0x8000
            SET [FACOV], 0
            RTS


; Move a FP number from FAC1 to various points in memory
:MOV2F
:STORE_FAC_IN_TEMP2_ROUNDED
:ROMBBC7
            SET X, FACTEMP2    ; arithmetic register #4
            IFE X, 0 ; skip next
:STORE_FAC_IN_TEMP1_ROUNDED
:ROMBBCA    SET X, FACTEMP1    ; arithmetic register #3
            IFE X, 0 ; skip next
:ROMBBD0    SET X, [FORPNT] ; assign to a BASIC variable
:STORE_FAC_AT_X_ROUNDED
:ROMBBD4    JSR ROUND
            ; using X instead of $22
            SET [X+2], [FACHO+1] ; low mantissa
            SET A, [FACSGN]
            BOR A, 0x7FFF 
            AND A, [FACHO] ; high mantissa combined with sign bit
            SET [X+1], A
            SET [X], [FACEXP]
            SET [FACOV], 0 
            ; uncomment if something relies on INDEX
            SET [INDEX], X
            RTS
            
; Move from FAC2 to FAC1
:MOVFA
:COPY_ARG_TO_FAC
:ROMBBFC    SET [FACSGN], [ARGSGN]
            SET [FACEXP], [ARGEXP]
:MOVFAHO
            SET [FACHO+1], [ARGHO+1]
            SET [FACHO], [ARGHO]
            SET [FACOV], 0
            RTS

:COPY_FAC_TO_ARG_ROUNDED
:ROMBC0C    JSR ROUND
:MOVEF
:MAF
:ROMBC0F    SET [ARGSGN], [FACSGN]
            SET [ARGHO+1], [FACHO+1]
            SET [ARGHO], [FACHO]
            SET [ARGEXP], [FACEXP]
            SET [FACOV], 0
            ; Preserve side effect in 6502 version
            SET A, [FACEXP]
            RTS

; Round Accumulator #1 by Adjusting the Rounding Byte
:ROUND
:ROMBC1B    IFE [FACEXP], 0
                RTS
            IFA [FACOV], -1
                RTS 
            ; high bit of FACOV is set, increment mantissa
:INCREMENT_MANTISSA
:ROMBC23    ADD [FACHO+1], 1
            ADX [FACHO], 0  
            IFE EX, 0
                RTS
            ; mantissa overflowed;
            ; shift it to the right
            JMP ROMB938
            
; get sign of float accu in A
:SIGN
:ROMBC2B    SET A, [FACEXP]
            IFE A, 0
                RTS
:ROMBC2F    SET A, [FACSGN]
; Return pure +1 or -1.
:ROMBC31    ASR A, 15
            BOR A, 1
            RTS

; SGN function
:SGNFUNC
:ROMBC39    JSR SIGN

:GIVAYF ;Convert 16-Bit Signed Integer to Floating Point
:ROMB391    SET [VALTYP], 0   ; numeric
            SET [FACHO], A
            SET X, 0x90 ; FAC < 32768
            JMP FLOAT1 ; normalize
            
; Move signed 8-bit number from A into float

:FLOAT
:ROMBC3C
            SHL A, 8
            SET [FACHO], A ; Mantissa
            SET [FACHO+1], 0
            SET X, 0x88      ; FAC < 128
:FLOAT1
:ROMBC44 ; EX contains sign of number
            SET EX, A
; Zero out rest of FACHO
:ROMBC49
            SET [FACEXP], X
            SET [FACHO+1], 0
            SET [FACOV], 0
            SET [FACSGN], 0
            JMP NORMALIZE_FAC1
            ;... does a COMPLEMENT_FAC if EX = -1,
            ; then normalizes the thing

; ABS FUNCTION
:ROMBC58
        SET [FACSGN], 0
        RTS
            
; ----------------------------------------------------------------------------
; COMPARE FAC WITH PACKED # AT (Y,A)
; RETURN A=1,0,-1 AS (Y,A) IS <,=,> FAC
; ----------------------------------------------------------------------------
:FCOMP
:ROMBC5B    SET I, A    ; I points to exponent
:FCOMPI
:ROMBC5D    SET X, [I]  ; X contains exponent
:ROMBC63    ADD I, 1    ; I points to mantissa
            IFE X, 0
                JMP SIGN    ; return sign of FAC1?
:ROMBC67    SET A, [I]  ; A contains mantissa 
            XOR A, [FACSGN]
            IFU A, 0        ; Comparing different signs
                JMP ROMBC2F ; return sign of FAC1.
            ; Compare exponent, then mantissa
            ; First byte that's different,
            ; return comparison of that byte.
:ROMBC6D    SUB X, [FACEXP]
            IFN X, 0  ; different exponents
                JMP ROMBC92
            SET X, [I]
            BOR X, 0x8000
            SUB X, [FACHO]
            IFN X, 0
                JMP ROMBC92
            SET X, [I+1]
            SUB X, [FACHO+1]
            IFN X, 0
                JMP ROMBC92
            ; try subtraction again,
            ; this time with the rounding bit
:ROMBC88    SET EX, 0
            IFU [FACOV], 0
                SET EX, -1
:ROMBC8C    SET X, [I+1]

            SBX X, [FACHO+1]
            SET A, 0
:ROMBC90    IFE X, 0
                RTS ; give up on comparison?
; in 6502, C=1 meant memory was higher..
; in DCPU-16, EX=0 meant memory was higher.
:ROMBC92    SET A, [FACSGN]
            IFE EX, 0 ; no underflow in the subtract
                XOR A, -1
            JMP ROMBC31 ; return pure 0 or 1

; ----------------------------------------------------------------------------
; QUICK INTEGER FUNCTION
;
; CONVERTS FP VALUE IN FAC TO INTEGER VALUE
; IN FAC+1...FAC+4, BY SHIFTING RIGHT WITH SIGN
; EXTENSION UNTIL FRACTIONAL BITS ARE OUT.
;
; THIS SUBROUTINE ASSUMES THE EXPONENT < 32.
; ----------------------------------------------------------------------------

:QINT
:ROMBC9B    SET A, [FACEXP]
            IFE A, 0
                JMP QINT3 ; clear mantissa and return
:ROMBC9F    SUB A, 0xA0
            IFA [FACSGN], -1
                JMP ROMBCAF ; skip two lines if positive
            SET [BITS], -1  ; shift 1s from the left instead of 0s
            JSR COMPLEMENT_FAC_MANTISSA
:ROMBCAF    SET X, FACEXP ; pointer
            IFA A, -8   ; CMP 0xF9
                JMP QINT2
            JSR SHIFT_RIGHT  ; shift by 8 bits
            SET [BITS], 0
:ROMBCBA    RTS

:QINT2
:ROMBCBB    SET Y, A
            SET A, [FACSGN]
            AND A, 0x8000
            SHR [FACHO], 1
            BOR [FACHO], A
            SET A, 0
            JSR SHIFT_RIGHT4 ; shift rest of FACHO to the right
            SET [BITS], 0
:ROMBCCB    RTS

:INT
:ROMBCCC    IFG [FACEXP], 0xA0  ; too big to have decimal places
                RTS
            JSR QINT
            SET [FACOV], 0
            SET EX, 0
            IFU [FACSGN], 0
                SET EX, -1
            SET [FACSGN], 0
            SET [FACEXP], 0xA0 ; exponent is 2**32
            SET [RAM07], [RAM64]
            JMP NORMALIZE_FAC1 ; re-normalize
 
:QINT3               
:ROMBCE9    SET [FACHO], 0
            SET [FACHO+1], 0
            RTS

:DECFLG    DAT 0
:FIN ; convert ascii string to a float in FAC1
:ROMBCF3    SET Y, 0
            SET X, 0
            SET [DECEXP], 0
            SET [RAM5E], 0
            SET [DECFLG], 0
            SET [RAM60], 0
            SET [FACEXP], 0
            SET [FACHO], 0
            SET [FACHO+1], 0
            SET [FACSGN], 0
            ; parse result from last CHRGET
            IF_IS_DIGIT
                JMP FIN9
            IFE A, 0x2D ; minus
                SET X, -1
            SET [SGNFLG], X
:ROMBD06    IFN A, 0x2B ; plus sign
                JMP ROMBD0F 
            ; get digit after +/-
:ROMBD0A    JSR CHRGET
            ; parse a digit
:ROMBD0D    IF_IS_DIGIT
                JMP FIN9
:ROMBD0F    IFE A, 0x2E ; decimal point
                JMP ROMBD41
            IFN A, 0x45 ; E
                JMP ROMBD47
            ; handle exponent notation
            JSR CHRGET
            IF_IS_DIGIT
                JMP GETEXP
            IFE A, BASIC_MINUS_TOKEN
                JMP ROMBD2E
            IFE A, 0x2D  ; minus
                JMP ROMBD2E
            IFE A, BASIC_PLUS_TOKEN
                JMP ROMBD30
            IFE A, 0x2B  ; plus
                JMP ROMBD30
            JMP ROMBD35
            ; handle negative exponent
:ROMBD2E    SET [RAM60], -1
:ROMBD30    JSR CHRGET
            IF_IS_DIGIT
                JMP GETEXP
:ROMBD35    IFN [RAM60], -1 ; bpl
                JMP ROMBD47
            SET A, 0
            SUB A, [RAM5E]
            JMP ROMBD49 ; subtract DECEXP and use.
            ; handle decimal point
:ROMBD41    SHR [DECFLG], 1       ; move existing decimal point flag
            BOR [DECFLG], 0x8000  ; set decimal point flag
            IFC [DECFLG], 0x4000 ; if decimal point flag already set
                JMP ROMBD0A ; ignore second decimal
            ; Normalize number with E+xx/E-xx notation.
:ROMBD47    SET A, [RAM5E]   
:ROMBD49    SUB A, [DECEXP]
            SET [RAM5E], A
            IFE A, 0
                JMP ROMBD62 ; no decimal point
            IFA A, -1 ; BPL
                JMP ROMBD5B
            ; Decimally denormalize number.
            ; RAM5E is the decimal exponent
            ; DECEXP is the number of digits to the right 
:ROMBD52    JSR DIV10
            ADD [RAM5E], 1
            IFN [RAM5E], 0
                JMP ROMBD52
            JMP ROMBD62
:ROMBD5B    JSR MUL10
            SUB [RAM5E], 1
            IFN [RAM5E], 0
                JMP ROMBD5B
:ROMBD62    SET A, [SGNFLG]
            IFU A, 0  ; BMI
                JSR NEGOP ; originally via BD67
            RTS
; handle a digit
:FIN9
:ROMBD6A    SET PUSH, A
            IFB [DECFLG], 0x8000 ; after a decimal point
                ADD [DECEXP], 1 ; increase decimal exponent
            JSR MUL10  ; multiply decimal mantissa regardless
            SET A, POP
            SUB A, 0x30 ; zero
            JSR ADDACC  ; add contents of digit
            JMP ROMBD0A ; go to next character
            
; Add A to FAC
:FINLOG
:ADDACC
:ROMBD7E    SET PUSH, A
            JSR COPY_FAC_TO_ARG_ROUNDED ; ARG = FAC
            SET A, POP
            JSR FLOAT  ; move A into FAC
            
            SET A, [ARGSGN]
            XOR A, [FACSGN]
            ASR A, 15
            SET [SGNCPR], A
            SET A, [FACEXP]
            JMP FADDT

; get E+xx/E-xx exponent from string
:GETEXP
:ROMBD91    SET A, [RAM5E] ; number of received digits
            IFL A, 10
                JMP ROMBDA0
            SET A, 100
            IFB [RAM60], 0x8000 ; BMI
                JMP ROMBDAE
            JMP OVERR ; ?OVERFLOW ERROR
            ; i think this handles E+XX
:ROMBDA0    MUL A, 10
            AND A, 0xFF ; simulate some 8-bit quirk
            SET Y, [RAM7A]
            ADD A, [Y]
            SUB A, 0x30 ; un-digit
:ROMBDAE    SHL A, 8 ; 8-bit quirk simulation
            ASR A, 8 ; continues
            SET [RAM5E], A
            JMP ROMBD30 ; get next expodigit
            
; constants for float to string conversion
:CON_99999999_9   DAT 0x9B, 0x3EBC, 0x1FFD
:CON_999999999    DAT 0x9E, 0x6E6B, 0x27FD
:CON_BILLION      DAT 0x9E, 0x6E6B, 0x2800


; print "IN <line>"
:INPRT
:ROMBDC2    SET A, ROMA371
            JSR STROUT ;originally ROMBDDA
            SET A, [CURLIN]

; print number from A (AX in original)

:LINPRT
:ROMBDCD    SET [FACHO], A
            SET X, 0x90 ;  exponent = 2^16
            SET EX, 0 ; don't run COMPLEMENT_FAC from B8D2
            JSR ROMBC49  ; normalize this
            SET Y, FLOATSTR ; Cut off initial space
            JSR FOUT1     ; convert float to string
            JMP STROUT   ; print
   
; location for floating point result
:FLOATSTR   
            DAT 0x20
            .FILL 0x20, 32
; output floating point number in FAC1
:FOUT
:ROMBDDD    SET Y, FLOATSTR+1
:FOUT1
:ROMBDDF    ;SET [FACOV], 0 ; TODO: cleanup
            SET A, 0x20    ; SPACE
            IFU [FACSGN], 0  ; negative
                SET A, 0x2D ; MINUS
            SET [Y], A
            SET [FACSGN], 0 ; was A -- 
            SET [RAM71], Y
            ADD Y, 1
            SET A, 0x30 ; zero
            SET X, [FACEXP]
            IFE X, 0
                JMP ROMBF04  ; write zero and exit
:ROMBDF8    SET A, 0
            IFE X, 0x80 ; exponent is a 1
                JMP ROMBE00
            IFG X, 0x80 ; number > 1
                JMP ROMBE09
; For numbers between 0 and 1, we skip 9 digits
:ROMBE00    SET A, CON_BILLION  ;  1,000,000,000
            JSR FMULT 
            SET A, -9 ; signify we've moved the decimal point
:ROMBE09    SET [DECEXP], A
:ROMBE0B    SET A, CON_999999999
            JSR FCOMP 
:ROMBE12    IFE A, 0  ; FAC1 = 999,999,999.5
                JMP ROMBE32
            IFC A, 0x8000 ; FAC1 > 999,999,999.5
                JMP ROMBE28 
:ROMBE16    SET A, CON_99999999_9
            JSR FCOMP
:ROMBE1D    IFE A, 0 ; fac1 = 99,999,999.5
                JMP ROMBE21 ; squeeze one more out
            IFC A, 0x8000 ; FAC1 > 99,999,999.5
                JMP ROMBE2F ; hundred millions digit done
:ROMBE21    ; Keep multiplying by 10 until
            ; the number is as big as we can print.
            JSR MUL10
            SUB [DECEXP], 1
            IFN [DECEXP], 0
                JMP ROMBE16
            ; Normalize downward.
:ROMBE28    JSR DIV10
:ROMBE2A    ADD [DECEXP], 1
            IFN [DECEXP], 1
                JMP ROMBE0B
            ; We've inflated our number, and the
            ; decimal exponent is in DECEXP.
:ROMBE2F    JSR FADDH ; add 0.5 to round the last visible digit
:ROMBE32    JSR QINT
:ROMBE35    SET X, 1
            SET A, [DECEXP]
            ADD A, 10
            IFB A, 0x8000 
                JMP ROMBE48
            IFG A, 10  ; More than 10 digits?
                JMP ROMBE48
:ROMBE42    ADD A, -1   
            SET X, A
            SET A, 2
:ROMBE48    SUB A, 2 
            SET [RAM5E], A
            ;Store the positive number of digits
            ; to the left of the decimal point.
            SET [DECEXP], X 
            SET A, X
            IFE A, 0
                JMP ROMBE53
            IFC A, 0x8000
                JMP ROMBE66
:ROMBE53    SET Y, [RAM71]   ; cached FLOATSTR index
            ADD Y, 1
            SET [Y], 0x2E ; decimal point
            IFE X, 0 ; 
                JMP ROMBE64
:ROMBE5E    ADD Y, 1    ; add 0 after decimal point
            SET [Y], 0x30
:ROMBE64    SET [RAM71], Y
:ROMBE66    SET B, FOUTBL
:ROMBE68    SET X, 0x80
:ROMBE6A    ADD [FACHO+1], [B+1]
:ROMBE6G    ADX [FACHO], [B]
            SET C, EX
            ADD X, 1  ; 6502: affects N, not C
            IFN C, 0
                JMP ROMBE8E
:ROMBE8A    IFC X, 0x80 ;BPL
                JMP ROMBE6A
            JMP ROMBE90 ;BMI
:ROMBE8E    IFB X, 0x80 ;BMI after BCD
                JMP ROMBE6A
:ROMBE90    SET A, X
            IFE C, 0
                JMP ROMBE97
:ROMBE93    XOR A, 0xFF
            ADD A, 12 ; ADC #10 when carry must bet set
:ROMBE97    ADD A, 0x2F ; ??
:ROMBE99    ADD B, 2 ; Try next divisor
            ;SET [VARPNT],B  ; Starting divisor cache
            SET Y, [RAM71] ; get cached string index
            ADD Y, 1
            SET X, A
:ROMBEA3    AND A, 0x7F
            SET [Y], A     ;Store a digit!
            SUB [DECEXP], 1
            IFN [DECEXP], 0 
                JMP ROMBEB2
            ADD Y, 1
            SET [Y], 0x2E ; Add decimal point
:ROMBEB2    SET [RAM71], Y ; Store string index
            ;SET B, [VARPNT]  ; Cached divisor value
            SET A, X
            XOR A, 0xFF
            AND A, 0x80  ; not sure the bittitude
            SET X, A
            IFE B, FOUTBLEND ; end of base 10 factors
                JMP ROMBEC4
            IFN B, FDCEND  ; end of TI$ factors
                JMP ROMBE6A  ; beginning of loop
:ROMBEC4    SET Y, [RAM71]
    ; shave off surplus decimal places
:ROMBEC6    SET A, [Y]
            SUB Y, 1
            IFE A, 0x30 ; zero
                JMP ROMBEC6
            IFE A, 0x2E ; decimal point
                JMP ROMBED3
            ADD Y, 1
:ROMBED3    SET A, 0x2B ; plus
            SET X, [RAM5E]
            IFE X, 0   ; Nothing more to print
                JMP ROMBF07
            ; What's in RAM5E anyway?
:ROMBED9    IFC X, 0x80 
                JMP ROMBEE3
:ROMBEDB    SET X, [RAM5E]
            MUL X, -1
            SET A, 0x2D ; minus
:ROMBEE3    SET [Y+2], A
            SET [Y+1], 0x45 ; E
:ROMBEEE    ; SEC
:ROMBEEF    SET A, X
            DIV A, 10
            ADD A, 0x30
            MOD X, 10
            ADD X, 0x30
            SET [Y+4], X
            SET [Y+3], A
            SET [Y+5], 0
            JMP ROMBF0C
:ROMBF04    SET [Y], A
:ROMBF07    SET [Y+1], 0
:ROMBF0C    SET A, FLOATSTR+1
            SET Z, 0
            RTS
            
; constant: 1/2 in floating point format
; for various rounding purposes.
:CON_HALF
:ROMBF11   DAT 0x80, 0x0000, 0x0000 

; divisors for decimal conversion
:FOUTBL
:ROMBF16   DAT 0xFA0A,0x1F00    ;-100,000,000
:ROMBF1A   DAT 0x0098,0x9680    ;  10,000,000
:ROMBF1E   DAT 0xFFF0,0xBDC0    ;  -1,000,000
:ROMBF22   DAT 0x0001,0x86A0    ;     100,000
:ROMBF26   DAT 0xFFFF,0xD8F0    ;     -10,000
:ROMBF2A   DAT 0x0000,0x03E8    ;        1000
:ROMBF2E   DAT 0xFFFF,0xFF9C    ;        -100
:ROMBF32   DAT 0x0000,0x000A    ;          10
:ROMBF36   DAT 0xFFFF,0xFFFF    ;          -1
:FOUTBLEND

; divisors for clock conversion (TI$)
:FDCEND
    DAT 0xFFDF,0x0A80 ;-2160000    10:00:00
    DAT 0x0003,0x4BC0 ;  216000     1:00:00
    DAT 0xFFFF,0x7360 ;  -36000       10:00
    DAT 0x0000,0x0E10 ;    3600        1:00
    DAT 0xFFFF,0xFDA8 ;    -600         :10
    DAT 0x0000,0x003C ;      60         :01 (1 second = 60 jiffies)
:FDCENDEND

; ----------------------------------------------------------------------------
; special case for X^2
; ----------------------------------------------------------------------------
:SQUARE
		JSR COPY_ARG_TO_FAC
		SET [ARISGN], 0
		JMP FMULTT
; ----------------------------------------------------------------------------
; SQR(X) = X^0.5
; ----------------------------------------------------------------------------
:SQR
        JSR COPY_FAC_TO_ARG_ROUNDED
        SET A, CON_HALF
        JSR MOVFM
        ; fall through to FPWRT
; ----------------------------------------------------------------------------
; EXPONENTIATION OPERATION
;
; ARG ^ FAC  =  EXP( LOG(ARG) * FAC )
; ----------------------------------------------------------------------------
:FPWRT
:ROMBF7B    IFE A, 0  ; ???
                JMP EXP
            IFE [ARGEXP], 0
                JMP ZERO_FAC ; return 0
			; special case for squares
            IFE A, 0x82
                IFE [FACHO+1], 0
                	IFE [FACHO], 0x8000
                		JMP SQUARE
            SET Y, 0
            SET X, FACTEMP3
            JSR STORE_FAC_AT_X_ROUNDED 
            SET A, [ARGSGN]
            IFA A, -1 ; BPL
                JMP ROMBF9E
            SET A, FACTEMP3
            JSR FCOMP
            IFE A, 0
                JMP ROMBF9E
            SET A, Y
            SET Y, [RAM07] 
:ROMBF9E    JSR COPY_ARG_TO_FAC ; TODO: original called ROMBBFE.
                    ; was this just for efficiency?
            SET PUSH, Y
            JSR LOG
            SET A, FACTEMP3
            JSR FMULT   ; FAC *= RAM4E
            JSR EXP ; EXP function
            SET A, POP
            ASR A, 1
            IFE EX, 0
                RTS
            

; MINUS operator
; Perform NOT and >
:NEGOP
:ROMBFB4    IFN [FACEXP], 0
                XOR [FACSGN], -1
            RTS

; float constants for EXP

; 1/LOG(2)
:CON_LOG_E
:ROMBFBF    DAT 0x81, 0x38aa, 0x3b29
; polynomial table
:POLY_EXP
:ROMBFC4    DAT 7 ; degree 8
            DAT 0x71,0x3458,0x3e56
            dat 0x74,0x167e,0xb31b
            dat 0x77,0x2fee,0xe385
            dat 0x7a,0x1d84,0x1c2a
            dat 0x7c,0x6359,0x580a
            dat 0x7e,0x75fd,0xe7c6
            dat 0x80,0x3172,0x1810
            dat 0x81,0,0

; EXP command
:EXP
:ROMBFED    SET A, CON_LOG_E  
            JSR FMULT
            SET A, [FACOV]
            ADD A, 0x5000
            IFN EX, 0
                JSR INCREMENT_MANTISSA
:ROME000    SET [ARGOV], A
            JSR MAF
            IFG [FACEXP], 0x87 ; FAC >= 256
:ROME00B        JSR OUTOFRNG
            JSR INT  ; does INT set [CHARAC]?
            SET A, [CHARAC]
            ADD A, 0x81
            IFC A, 0xFF ; BEQ in 8-bit
                JMP ROME00B
            SUB A, 1
            SET PUSH, A
            ; Swap FAC and ARG
            SET A, [FACEXP]
            SET X, [FACHO]
            SET Y, [FACHO+1]
            SET [FACEXP], [ARGEXP]
            SET [FACHO], [ARGHO]
            SET [FACHO+1], [ARGHO+1]
            SET [ARGEXP], A
            SET [ARGHO], X
            SET [ARGHO+1], Y
            SET [FACOV], [ARGOV]
            JSR FSUBT
            JSR NEGOP
            SET A, POLY_EXP ; EXP polynomial table
            JSR POLYNOMIAL
            SET [SGNCPR], 0
            SET A, POP
            JSR ADD_EXPONENTS1 ; add FAC/ARG exponents
            RTS    
            

; float numbers for RND
:ROME08D    DAT 0x98, 0x3544, 0x7A00  ; multiplied by this
:ROME092    DAT 0x68, 0x2881, 0x4600  ; added to this

; ----------------------------------------------------------------------------
; ODD POLYNOMIAL SUBROUTINE
;
; F(X) = X * P(X^2)
;
; WHERE:  X IS VALUE IN FAC
;    A POINTS AT COEFFICIENT TABLE
;    FIRST BYTE OF COEFF. TABLE IS N
;    COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
;
; P(X^2) COMPUTED USING NORMAL POLYNOMIAL SUBROUTINE
; ----------------------------------------------------------------------------
:POLYNOMIAL_ODD
:ROME043    SET [RAM71], A
            JSR STORE_FAC_IN_TEMP1_ROUNDED
            SET A, FACTEMP1
            JSR FMULT
            JSR SERMAIN
            SET A, FACTEMP1
            JMP FMULT

; ----------------------------------------------------------------------------
; NORMAL POLYNOMIAL SUBROUTINE
;
; P(X) = C(0)*X^N + C(1)*X^(N-1) + ... + C(N)
;
; WHERE:  X IS VALUE IN FAC
;    A POINTS AT COEFFICIENT TABLE
;    FIRST BYTE OF COEFF. TABLE IS N
;    COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
; ----------------------------------------------------------------------------
:POLYNOMIAL
:ROME059    SET [RAM71], A
:SERMAIN
:ROME05D    JSR STORE_FAC_IN_TEMP2_ROUNDED ; move FAC1 to FACTEMP2
            SET Y, [RAM71]
:ROME060    SET [SERLEN], [Y]
            ADD Y, 1
            SET [RAM71], Y
            SET A, Y
:ROME070    JSR FMULT
            SET A, [RAM71]
            ADD A, 3
            SET [RAM71], A
            JSR FADD
            SET A, FACTEMP2
            SUB [SERLEN], 1
            IFN [SERLEN], 0
                JMP ROME070
            RTS
            

; RND FUNCTION
:RND
:ROME097    JSR SIGN
            IFE A, -1
                JMP ROME0D3
            IFE A, 1
                JMP ROME0BE
            JSR ROMFFF3
            SET I, X
            ; apparently I'm supposed to re-seed
            ; FACHO with 32 bits of randomness
            ; coming from there... not sure
            ; what the best DCPU equialent is
            ; just yet.
:ROME0BE    SET A, RNDX ; RND seed in RAM
            JSR MOVFM
            SET A, ROME08D
            JSR FMULT
            SET A, ROME092
            JSR FADD
            ; jumble bytes
:ROME0D3    SET A, [FACHO]
            SET X, [FACHO+1]
            SHR A, 8
            BOR A, EX 
            SHL X, 8
            BOR X, EX
            SET [FACHO+1], A
            SET [FACHO], X
:ROME0E3    SET [FACSGN], 0
            SET [FACOV], [FACEXP]
            SET [FACEXP], 0x80 ; LET FAC < 1
            JSR NORMALIZE_FAC2 ; Normalize
            SET X, RNDX
:ROME0F6    JMP STORE_FAC_AT_X_ROUNDED 

; COS function
:COS
:ROME264    SET A, CON_PI_HALF
            JSR FADD
; SIN function
:SIN
:ROME26B    JSR COPY_FAC_TO_ARG_ROUNDED
            SET A, CON_PI_DOUB
            SET X, [ARGSGN]
            JSR DIV
            JSR COPY_FAC_TO_ARG_ROUNDED
            JSR INT   ; really?
            SET [SGNCPR], 0
            JSR FSUBT
; ----------------------------------------------------------------------------
; (FAC) = ANGLE AS A FRACTION OF A FULL CIRCLE
;
; NOW FOLD THE RANGE INTO A QUARTER CIRCLE
;
; <<< THERE ARE MUCH SIMPLER WAYS TO DO THIS >>>
; ----------------------------------------------------------------------------
            SET A, QUARTER
            JSR FSUB
            SET A, [FACSGN]
            SET PUSH, A
            IFA A, -1
            JMP SIN1
            JSR FADDH
            SET A, [FACSGN]
            IFU A, 0
                JMP ROME2A0
            XOR [RAM12], -1 ; ???
:SIN1
:ROME29D    JSR NEGOP
:ROME2A0    SET A, QUARTER
            JSR FADD
            SET A, POP
            IFA A, -1
                JMP ROME2AD
            JSR NEGOP
:ROME2AD    SET A, POLY_SIN
            JMP POLYNOMIAL_ODD

; TAN function
:TAN
:ROME2B4    JSR STORE_FAC_IN_TEMP1_ROUNDED
            SET [RAM12], 0
            JSR SIN
            SET X, [FACTEMP3]
            JSR ROME0F6 ; round FAC1 and move to X
            SET A, FACTEMP1
            JSR MOVFM   ; FAC1 <- FACTEMP1
            SET [FACSGN], 0
            SET A, [RAM12]
            JSR ROME2DC
            SET A, [FACTEMP3]
            JMP FDIV ; ohshi--

:ROME2DC    SET PUSH, A
            JMP SIN1

; ----------------------------------------------------------------------------
; "ATN" FUNCTION
; ----------------------------------------------------------------------------
:ATN
        SET A, [FACSGN]
    SET PUSH, A
    IFA A, -1
            JMP L3FDB
        JSR NEGOP
:L3FDB
        SET A, [FACEXP]
        SET PUSH, A
        IFL A, 0x81
            JMP L3FE9
        SET A, FONE
        JSR FDIV
; ----------------------------------------------------------------------------
; 0 <= X <= 1
; 0 <= ATN(X) <= PI/8
; ----------------------------------------------------------------------------
:L3FE9  SET A, POLY_ATN
        JSR POLYNOMIAL_ODD
        SET A, POP
        IFL A, 0x81
            JMP L3FFC
        SET A, CON_PI_HALF
        JSR FSUB
:L3FFC  SET A, POP
        IFU A, 0
            JMP NEGOP
        RTS

:POLY_ATN
        DAT 11
        DAT 0x76,0xB383,0xBDD3
        DAT 0x79,0x1EF4,0xA6F5
        DAT 0x7B,0x83FC,0xB010
        DAT 0x7C,0x0C1F,0x67CA
        DAT 0x7C,0xDE53,0xCBC1
        DAT 0x7D,0x1464,0x704C
        DAT 0x7D,0xB7EA,0x517A
        DAT 0x7D,0x6330,0x887E
        DAT 0x7E,0x9244,0x993A
        DAT 0x7E,0x4CCC,0x91C7
        DAT 0x7F,0xAAAA,0xAA13
        DAT 0x81,0x0000,0x0000

            
; float numbers for trigonometry

:CON_PI_HALF
:ROME2E0    DAT 0x81, 0x490F, 0xDAA2
:CON_PI_DOUB
:ROME2E5    DAT 0x83, 0x490F, 0xDAA2
:QUARTER    DAT 0x7F, 0, 0

; Polynomial table
:POLY_SIN
:ROME2EF    DAT 5  ; degree 6
            DAT 0x84, 0xE61A, 0x2D1B
            DAT 0x86, 0x2807, 0xfbf8
            DAT 0x87, 0x9968, 0x8901
            DAT 0x87, 0x2335, 0xdfe1
            DAT 0x86, 0xa55d, 0xe728
            DAT 0x83, 0x490f, 0xdaa2

:XFACCRASH  SET I, [X+1]
            SET J, [X+2]
            SET EX, [X]
            SET Z, [X+3]
            JMP CRASH
:FACCRASH   SET B, [ARGHO]
            SET C, [ARGHO+1]
            SET X, [ARGEXP]
            SET A, [ARGSGN]
            SET Y, [SGNCPR]
            SET I, [FACHO]
            SET J, [FACHO+1]
            SET EX, [FACEXP]
            SET Z, [FACSGN]
            ;SET Z, [FACOV]
            BOR 0xBCBC, 0xBCBC
            JMP CRASH


; keyboard constants
.DEFINE DCPU_BACKSPACE, 0x10
.DEFINE DCPU_RETURN, 0x11
.DEFINE DCPU_INSERT, 0x12
.DEFINE DCPU_DELETE, 0x13
.DEFINE DCPU_UP, 0x80
.DEFINE DCPU_DOWN, 0x81
.DEFINE DCPU_LEFT, 0x82
.DEFINE DCPU_RIGHT, 0x83
.DEFINE DCPU_SHIFT, 0x90
.DEFINE DCPU_CTRL, 0x91
.DEFINE DCPU_STOP, 0x1B

:RAM91 ; stop key flag
:STKEY  DAT 0
:RAMC5  ; Code of last key pressed
:LSTX   DAT 0
:RAMC6  ; Number of Characters in Keyboard Queue
:NDX    DAT 0

; Handle keyboard interrupts by storing keystrokes in
; special RAM locations, where they'll be picked up by 
; the clock interrupt.
:KEYASCII .DAT 0

; 0x01: shift
; 0x05: control
; this doesn't work on any known implementation yet
:KEYSHIFT .DAT 0

:RAM028A
:RPTFLAG    DAT 0
:RAM028B
:KOUNT      DAT REPEAT_FRAMES_B
:RAM028C
:DELAY      DAT REPEAT_FRAMES_A
:RAM028D
:SHFLAG     DAT 0
:RAM028E
:LSTSHF     DAT 0
:RAM028F
:KEYLOG     DAT 0 ; ROM?

;------------------------------------------------------
:LP2       ; get a character from the keyboard buffer
:ROME5B4    SET A, [KEYD] 
            SET X, 0
:ROME5B9    SET [KEYD+X], [KEYD+1+X]
            ADD X, 1
            IFN X, [NDX]
               JMP ROME5B9
            SUB [NDX], 1
            IAQ 0
            SET C, 0  ; no error
            RTS

;-----------------------------------------------------------
; KEYBOARD INTERRUPT ROUTINE - triggered by keyboard events
; keeps a steady state of which keys are being held down.
; does not affect the keyboard buffer at all.
;-----------------------------------------------------------
:KEYINT
    SET PUSH, B
    SET PUSH, C
    SET A, 2 ; check key
    SET B, DCPU_CTRL
    HWI [KEYBOARD]
    SHL C, 2  
    SET [KEYSHIFT], C
    SET A, 2 ; check key
    SET B, DCPU_SHIFT
    HWI [KEYBOARD]
    BOR [KEYSHIFT], C
    SET A, 1  ; get from queue
    HWI [KEYBOARD]
    IFG C, 0x9F ; strange high ascii in 0x10co.de
        JSR HIGHASCII
    IFL C, 0x90
        SET [KEYASCII], C ; for scanning during clock interrupt
    SET B, -1
    IFE C, DCPU_STOP
        SET B, 0x7F
    SET [RAM91], B
    ;SET A, 2 ; check key
    ;SET B, [KEYASCII] ; original key
    ;; check for key-up event here
    ;HWI [KEYBOARD]
    ;IFE C, 0
    ;    SET [KEYASCII], 0
    SET C, POP
    SET B, POP
    RFI 5

; 0x10co.de + chrome gives us strange keystrokes
; where it adds 0x80 to them. this fixes most of them
; I hesitate to do anything else due to the probability
; that it won't work on non-US keyboards.
:HIGHASCII
    SET A, C
    SUB A, 0x80
    IFB [KEYSHIFT], 1
        JMP HIGHASCII_SHIFT
    ; translations without SHIFT
    IFE A, 0x40
        SET A, 0x5F ; underscore (leftarrow)
    IFL A, 0x40
        XOR A, 0x10 ; change ,-./ to <=>?
    IFE A, 0x2B ; was a plus w/o shift key
        ADD A, 18 ; equals sign
    IFE A, 0x2A ; was a colon w/o shift key
        ADD A, 17 ; semicolon
    IFE A, 0x5E
        SET A, 0x27 ; apostrophe
    SET C, A
    RTS
:HIGHASCII_SEMICOLON
    ADD A, 1
:HIGHASCII_SHIFT
    IFE A, 0x3B ; semicolon with shift key
        SUB A, 0x10 ; is really a plus sign
    IFE A, 0x5E
        SET A, 0x22 ; double quote
    IFE A, 0x40
        SET A, 0x7E   ; tilde (pi)
:HIGHASCII_END
    SET C, A
    RTS



:SCANSHIFT
    ; allow typing ( in 0x10co.de
    IFE [KEYASCII], 0x81
        SET [KEYASCII], 0x28
    ; allow typing & in 0x10co.de
    IFE [KEYASCII], 0x80
        SET [KEYASCII], 0x26
:SCANREG
    SET Y, [KEYASCII]
    IFL Y, 0x20
        JMP SCANSPECIAL
    IFB Y, 0x80
        JMP SCANARROWS
    IFE Y, 0x7E     ; TILDE
        JMP SCAN_PI 
    SET [SFDX], Y
    ; handle letter shifting
    IFG Y, 0x60 ; lowercase letters
        SUB [SFDX], 0x20  ; are "unshifted"
    IFG Y, 0x40
      IFL Y, 0x5B
        ADD [SFDX], 0x80
    RTS

:SCAN_PI
    SET [SFDX], 0xFF
    RTS

:SCANSPECIAL
    SET [SFDX], CBM_RETURN
    IFE Y, DCPU_INSERT
        SET [SFDX], CBM_INSERT
    IFE Y, DCPU_BACKSPACE
        JMP SCAN_DELETE
    IFN Y, DCPU_DELETE
        JMP SCAN_NOT_DELETE
:SCAN_DELETE
    IFC [SHFLAG], 1  ; unshifted
        SET [SFDX], CBM_DELETE
    IFB [SHFLAG], 1  ; shifted
        SET [SFDX], CBM_INSERT
:SCAN_NOT_DELETE
    RTS

:CTRL_COLORS
    DAT 0x92, 0x90, 0x05, 0x1c, 0x9f, 0x9c, 0x1E, 0x1F, 0x9E, 0x12
:CBMKEY_COLORS
    DAT 0x92, 0x81, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x12 

:SCANCTRL
    SET [SFDX], CBM_RETURN
    SET Y, [KEYASCII]
    SET A, CTRL_COLORS-0x30
    ADD A, Y
    IFG Y, 0x2F
        IFL Y, 0x3A
            SET [SFDX], [A]
    ; ctrl-letter
    SET A, Y
    AND A, 63
    IFG A, 0
        IFL A, 30
            SET [SFDX], A
    ; lowercase mode with ctrl-n or ctrl-.
    ; uppercase mode with ctrl-,
    IFE A, CBM_COMMA
        SET [SFDX], 142 
    IFE A, 0x2E ; .
        SET [SFDX], 14 
    IFE A, 0x3D  ; =
        SET [SFDX], 0x13  ; HOME
    IFE A, 0x2D ; + 
        SET [SFDX], 0x93  ; CLR
    RTS

; TODO: CBM-graphics characters

:SCANCBM
    SET Y, [KEYASCII]
    SET A, CBMKEY_COLORS-0x30
    ADD A, Y
    IFG Y, 0x2F
        IFL Y, 0x39
            SET [SFDX], [A]
    SET A, Y
    IFE A, 0x3D  ; =
        SET [SFDX], 0x93  ; CLR
    IFE A, 0x2D ; + 
        SET [SFDX], 0x93  ; CLR
    RTS

:SCANARROWS
    IFE Y, DCPU_RIGHT
        SET [SFDX], CBM_RIGHT 
    IFE Y, DCPU_DOWN
        SET [SFDX], CBM_DOWN 
    IFE Y, DCPU_LEFT
        SET [SFDX], CBM_LEFT
    IFE Y, DCPU_UP
        SET [SFDX], CBM_UP 
    RTS

;-----------------------------------------------------------
; KEYBOARD SCAN ROUTINE -- called every 1/60 of a second
;-----------------------------------------------------------
:ROMEA87 
    JSR DISPLAY_INPUT_BUFFER    
    SET [SHFLAG], [KEYSHIFT]
    SET [SFDX], 0x407F ; code for NO KEY PRESSED
        IFE [KEYASCII], 0
            JMP ROMEAE0
        IFC [KEYSHIFT], 0x07 ; no shift-ctrl
        JSR SCANREG
    IFE [KEYSHIFT], 0x01 ; SHIFT only
        JSR SCANSHIFT
    IFE [KEYSHIFT], 0x04 ; CTRL only
        JSR SCANCTRL
    IFE [KEYSHIFT], 0x05 ; CBM (shift+ctrl)
        JSR SCANCBM
        JSR DISPLAY_KEY_DEBUG
        ;JSR DISPLAY_LINK_TABLE
:ROMEAE0
    SET Y, [SFDX] ; key being pressed
        SET A, Y   ; [SFDX] contains the actual value, not scan code
        SET X, A   ; because EAE4 said so
    IFE [SFDX], [LSTX]
        JMP ROMEAF0
    SET [RAM028C], REPEAT_FRAMES_A   ; key repeat speed
;   SET [RAM028B], REPEAT_FRAMES_B   ; key repeat speed
    JMP ROMEB26
:ROMEAF0 
    ; clear shift bit so that we can test for
    ; a character and its shifted equivalent
    ; at the same tims.
    SET Y, A
    AND Y, 0x407F
:ROMEAF2
    ; handle key repeat logic
    IFB [RAM028A], 0x80
        JMP ROMEB0D ; repeat all characters
    IFB [RAM028A], 0x40
        RTS        ; repeat no characters
    IFB Y, 0x4000  ; no key pressed
        JMP ROMEB26
    ; repeat only these characters
    IFE Y, CBM_DELETE  ;and insert
        JMP ROMEB0D
    ; software-repeating space gets stuck in dtemu.
    ;IFE Y, 0x20 ; SPACE
    ;    JMP ROMEB0D
    IFE Y, CBM_RIGHT ; cursor right/left
        JMP ROMEB0D
    IFN Y, CBM_DOWN ; cursor up/down
        RTS
:ROMEB0D ; repeat this key
    IFE [RAM028C], 0
        JMP ROMEB17
    SUB [RAM028C], 1
    IFN [RAM028C], 0
        RTS
:ROMEB17
    SUB [RAM028B], 1
    IFN [RAM028B], 0
        RTS
:ROMEB1C    SET [RAM028B], REPEAT_FRAMES_B ; repeat speed
:ROMEB21   
            SET X, [NDX]
            SUB X, 1
            IFA X, -1 ; BPL
                RTS
:ROMEB26 ; no key pressed
            SET [LSTX], [SFDX]
            IFN [LSTSHF], [0x01]
                JMP SKIPSHIFTCBM
            IFE SHFLAG, 0x05
                JSR TOGGLEFONT ; why doesn't this work
:SKIPSHIFTCBM
            SET [LSTSHF], [SHFLAG]
            IFB A, 0x4000 ; no key pressed
                RTS
:ROMEB35
            SET X, [NDX]
            IFG X, KEYBOARD_BUFFER_SIZE  ; keyboard buffer overflow
                RTS
:ROMEB3C    ; Add A to keybuard queue
            SET [KEYD+X], A
            ADD [NDX], 1
:ROMEB47
            RTS

:DISPLAY_INPUT_BUFFER
    SET PUSH, X
    SET PUSH, I
    SET PUSH, J
    SET I, [FREETOP]
    SET J, DEBUGLNK-1
:BUFLOOP
    STI X, [I]
    IFC X, 0xFF00
        JMP BUF99
    AND X, 0xFF
    BOR X, 0xB300
    JMP BUF88
:BUF99
    BOR X, 0x6E00
:BUF88 SET [J], X
    IFL J, DEBUGLNK+15
    JMP BUFLOOP
    SET J, POP
    SET I, POP
    SET X, POP
RTS

; Screen output and screen editor input
;
; Uses PETSCII.  In the future, I'll make an ASCII version of this that
; makes more sense on the DCPU.
;
:RAMC7 ; Reverse text? 0=no
:RVS    DAT 0
:RAMC8 ; Pointer: end of logical line for input
:INDX   DAT 0
:RAMC9 ; Cursor X,Y position at start of input
:LXSP   DAT 0
:RAMCA  DAT 0
:RAMCB ; Code of Current Key Pressed
:SFDX   DAT 0
:RAMCC  ; 0 = Flash Cursor
:BLNSW  DAT 0
:RAMCD  ; Countdown to blink cursor
:BLNCT  DAT 0
:RAMCE  ; Character under cursor
:GDBLN  DAT 0
:RAMCF ; Was last cursor blink on or off?
:BLNON  DAT 0
:RAMD0 ; Input from Keyboard (0) or Screen (3)
:CRSW   DAT 0
:RAMD1  ;Pointer to the Address of the Current Line
:PNT    DAT 0
:RAMD3 ;Cursor Column on Current Line
:PNTR   DAT 0
:RAMD4 ; Quote Mode (0=No)
:QTSW   DAT 0
:RAMD5 ; End of current line
:LNMX   DAT HW_COLS-1
:RAMD6 ; Current physical line number
:TBLX   DAT 0
; code of final character
:RAMD7  DAT 0
:INSRT
:RAMD8 DAT 0
; Screen line link table
.DEFINE DL_UNLINKED, 0x80
:LDTB1
:RAMD9
    .FILL DL_UNLINKED, HW_ROWS+1
:RAM0287
:GDCOL  DAT 0xe620
:RAM0288
:HIBASE DAT SCREENMEM
;
:RAM0286
:COLOR  DAT 0xE600
;
; AUTODN controls a subtle change in behavior between
; printing and typing.
:RAM0292
:AUTODN     DAT 0
;
; Temporary index to the next line for screen scrolling
:RAM02A5    DAT 0

:SCREENMEM    
            .FILL BLANK,  HW_COLS*HW_ROWS
:SCREENMEMEND
; when HW_ROWS < 12, the bottom line displays
; various debugging information.
:DEBUGSPC
          DAT 0xA004, 0xA002, 0xA03A, 0xA020 ; "DB: "
; debug keyboard I/O
          DAT 0xA00B, 0xA03A ; "K:"
:DEBUGKEY
          .FILL BLANK, 10
; debug line link tbl
        DAT 0xA00C, 0xA03A ; "L:" 
:DEBUGLNK 
        .FILL BLANK, 14
; debug vblank interrupt
          DAT 0xA009, 0xA03A; "I:"
:DEBUGINT
          .FILL BLANK, 6

          .FILL 0xA02E, HW_COLS-29

; get screen geometry
:DEF_SCREEN
:ROME505    SET X, HW_COLS
            SET Y, HW_ROWS
            RTS

; set cursor x/y
:DEF_PLOT
:ROME50A   IFN C, 0
              JMP ROME513
           SET [TBLX], X  ; Line number
           SET [PNTR], Y  ; Column
           JSR ROME56C
 :ROME513  SET X, [TBLX]
           SET Y, [PNTR]
           RTS

; initialize screen and keyboard
:ROME518    
            ;JSR ROME5A0 ; initialize VIC chip - skip
            SET [MODE], 0
            SET [BLNON], 0   
            SET [RAM028F], ROMEB48
            SET [BLNCT], 12
            SET [BLNSW], 12
            SET [XMAS], 10
            SET [RAM028A], 10
            SET [COLOR], 0xE600 ; lt blue on blue
            SET [RAM028C], REPEAT_FRAMES_A   ; key repeat speed
            SET [RAM028B], REPEAT_FRAMES_B   ; key repeat speed
:ROME544    ; Initialize screen link table
            ; and clear the screen.  The 16-bit
            ; version doesn't need to attach
            ; the high byte of memory to this.
            SET I, LDTB1
            SET J, 0
:LINCLRLOOP STI [I], DL_UNLINKED
            IFN J, HW_ROWS+1
                JMP LINCLRLOOP
            SET X, HW_ROWS-1
:ROME560    JSR ROME9FF  ; clear one screen line
            SUB X, 1
            IFA X, -1 ; BPL
                JMP ROME560
:ROME566 ; HOME cursor
            SET [PNTR], 0 ; column 0
            SET [TBLX], 0 ; row 0
; set address of current screen line
:ROME56C
            SET X, [TBLX]
:ROME570    SET Y, [X+LDTB1]
            IFB Y, DL_UNLINKED
                JMP ROME57C
            ; this is 32 characters further
            ; in the previous line
            ADD [PNTR], HW_COLS
            SUB X, 1
            IFA X, -1
                JMP ROME570
:ROME57C    JSR ROME9F0 ; set PNT line pointer
            SET A, HW_COLS-1
            ADD X, 1
:ROME582    SET Y, [X+LDTB1]
            IFB Y, DL_UNLINKED
                JMP ROME58C
            ADD A, HW_COLS
            ADD X, 1
            JMP ROME582
:ROME58C    SET [LNMX], A ; maximum line length
            ;JMP ROMEA24
            RTS
:ROME591    IFN X, [LXSP]
                RTS
            JMP ROME6ED ; find beginning of logical line

; WAIT FOR RETURN FOR KEYBOARD
:ROME5CA    JSR ROME716 ; output to the screen
:ROME5CD    SET A, [NDX]
            SET [BLNSW], A  ; only blink if buffer is empty
            SET [AUTODN], A ; Don't scroll until buffer is empty
            IAQ 0 ; the c64 didn't have to manually enable ints here
            IFE A, 0
                JMP ROME5CD ; Loop until something changes?
:ROME5D6    IAQ 1 ; SEI
            IFE [BLNON], 0
                JMP ROME5E7
            ; restore haracter under cursor
            SET [BLNON], 0
            SET [BLNCT], 2
            SET A, [PNT]
            ADD A, [PNTR]
            SET [A], [GDBLN]
:ROME5E7    JSR ROME5B4 ; get character from buffer
            ;IFN A, CBM_RUN ; RUN key
            ;    JMP ROME5FE
            ; copy LOAD and RUN into buffer
            ;SET X, 9
            ;IAQ 1
            ;SET [NDX], X
:ROME5F3    ;DAT 0x5000
            ;JMP ROME5CD
:ROME5FE    IFN A, CBM_RETURN 
                JMP ROME5CA
            SET Y, [LNMX]
            SET [CRSW], Y
            ADD Y, [PNT]
:ROME606    SET A, [Y]
            AND A, 0xFF
            IFN A, 0x20 ; SPACE
                JMP ROME60F
            SUB Y, 1
            IFN Y, [PNT] ; TODO: fix off-by-one
                JMP ROME606
:ROME60F    ADD Y, 1
            SET [INDX], Y ; mark end of logical line
:ROME612    SET [AUTODN], 0 ; don't insert new lines when printing
            SET [PNTR],   0 ; beginning of line
            SET [QTSW],   0 ; turn off quote mode
            SET A, [LXSP] ; get column at start of input
            IFG [LXSP], 0x7F ; BMI
                JMP ROME63A ; get chr from screen
            SET X, [TBLX]  
:ROME621    JSR ROME591
            IFN X, [LXSP]
                JMP ROME63A  ; get chr from screen
            SET A, [LXSP+1]
            SET [PNTR], A
            IFU A, [INDX]  
                JMP ROME63A  ; get chr from screen
            JMP ROME65D
:ROME632    ; get character from device 0 or 3
            SET PUSH, Y
            SET PUSH, X
            IFE [CRSW], 0
                JMP ROME5CD ; blink cursor, etc
; get character from current screen line
:ROME63A    SET Y, [PNTR]
            ADD Y, [PNT] ; Y <- current character location
            SET A, [Y]   ; A <- current character byte
; TODO: handle RVS text better
            AND A, 0xFF
            SET [RAMD7], A
            AND A, 0x3F
            ; TODO: clean up for DCPU-16.
:ROME642    ; we don't need anyu shifting here
            ;SHL [RAMD7], 1
:ROME646    IFC [RAMD7], 0x40  ; original 0x40
                JMP ROME64A
            BOR A, 0x80
:ROME64A    IFC [RAMD7], 0x80         ; original 0x80
                JMP ROME650
            IFN X, [QTSW]
                JMP ROME654
:ROME650    IFB [RAMD7], 0x20   ; ASCII punctuation range
                JMP ROME654    ; leave undisturbed
:ROME652    BOR A, 0x40  ; 
:ROME654    ADD [PNTR], 1
            IFE A, CBM_QUOTE
                XOR [QTSW], 1
:ROME659    IFN Y, [INDX]
                JMP ROME674
:ROME65D    SET [CRSW], 0 ; 
            SET A, CBM_RETURN
            IFE [DFLTN], 3
                JMP ROME66F
            IFE [DFLTO], 3
                JMP ROME672
:ROME66F    JSR ROME716 ; output to the screen
:ROME672    SET A, CBM_RETURN  ; Register EOL
:ROME674    SET [RAMD7], A ; code of final character
            SET X, POP
            SET Y, POP
            IFE A, 0xDE ; screen PI code
                SET A, 0xFF ; petscii PI code
:ROME682    SET EX, 0  ; clc
                SET C, 0
            RTS

; create an XOR mask that swaps the background and
; foreground colors.  The screen editor doesn't need to
; know about text printed in reverse -- just control
; characters, which still have the blink bit on.
:RVS_ON
			SET A, [COLOR]
			SET X, A
			SHR A, 4
			XOR A, X
			SHR A, 4
			XOR A, X
			SHL A, 4
			AND A, 0xFF00
			SET [RVS], A
			JMP ROME6A8

; fill screen at current position
:ROME691    BOR A, 0x40
:ROME693    SET X, [COLOR]
            XOR X, [RVS]    ; visual reverse only
               JMP ROME699
; fill purposely with a control character
:ROME697    SET X, [COLOR]
            SHL X, 4
        SET B, EX
            SHL X, 4
            SET X, EX
            SHL X, 4
            BOR X, B
            SHL X, 8 
            BOR A, 0x80  ; this means "blink" on LEM.
:ROME699    IFN [INSRT], 0
                SUB [INSRT], 1
            ; TODO: proper RVS handling
            JSR ROMEA13 ; place character on screen
            JSR ROME6B6 ; advance cursor

; return from output to the screen
:ROME6A8
            SET J, POP
            SET I, POP
            SET Y, POP
            IFN [INSRT], 0
                SHR [QTSW], 1
            SET X, POP
            SET A, POP
            SET EX, 0
            IAQ 0  ; RE-ENABLE INTERRUPTS
            RTS



;advance the cursor, Get/insert new line
:ROME6B6    JSR ROME8B3 ; move cursor to next line if 
                   ; at end of line -- X will equal old line number
            ADD [PNTR], 1
            IFL [LNMX], [PNTR]
                JMP ROME6C1
            RTS
:ROME6C1    ; this branch is for when you type past the maximum logical line length
            IFE [LNMX], HW_COLS*ROWS_IN_LINE-1
                JMP ROME6F7  ; just move to next line
            IFN [AUTODN], 0  ; if typing and not just printing
                JMP ROME967 ; insert blank line underneath
:ROME6CD    SET X, [TBLX]  ; current row
            IFL X, HW_ROWS  
                JMP ROME6DA ; skip scrolling
            JSR ROME8EA  ; scroll the screen first
            SUB [TBLX], 1
            SET X, [TBLX]
            ; link current line (X) with next line
:ROME6DA    AND [LDTB1+X], 0xFFFF-DL_UNLINKED
            BOR [LDTB1+1+X], DL_UNLINKED
:ROME6E6    ADD [LNMX], HW_COLS
:ROME6ED    IFB [LDTB1+X], DL_UNLINKED
                JMP ROME6F4
            SUB X, 1
            IFN X, 0
                JMP ROME6ED
:ROME6F4    JMP ROME9F0 ; set PNT line pointer to X
:ROME6F7    SUB [TBLX], 1
            JSR ROME87C ; Move cursor to next line
            SET [PNTR], 0 ; beginning of
            RTS
; move backwards over a line boundary
:ROME701    SET X, [TBLX]
            IFN X, 0 ; at top of screen?
                JMP ROME70B
            SET [PNTR], 0 ; ?  column 0
            ;SET A, POP  ; not sure why we pop
            ;SET A, POP
            ;IFN A, 0
                JMP ROME6A8
:ROME70B    SUB X, 1
            SET [TBLX], X
            JSR ROME56C
            SET [PNTR], [LNMX] ; end of line?
            RTS


; SET NEXT LINE NUMBER

:ROME87C    SHR [LXSP], 1 ; LSR $C9?
            SET X, [TBLX]
:ROME880    ADD X, 1
            IFE X, HW_ROWS
                JSR ROME8EA ; scroll the screen
            IFC [X+LDTB1], DL_UNLINKED  ; if linked
                JMP ROME880 ; repeat test with next line
            SET [TBLX], X
:ROME88E    JMP ROME56C ; Set PNT to current line

; action for RETURN
:ROME891    SET [INSRT], 0
            SET [RVS], 0
            SET [QTSW], 0
            SET [PNTR], 0 ; column 0
            JSR ROME87C ; Move cursor to next line
            JMP ROME6A8 ; Return from outputting

; move cursor to previous line if at start of line
:ROME8A1    SET X, ROWS_IN_LINE ;2
            SET A, 0
:ROME8A5    IFE [PNTR], A  ;
                JMP ROME8B0
            ADD A, HW_COLS 
            SUB X, 1
            IFN X, 0
                JMP ROME8A5
            RTS
:ROME8B0    SUB [TBLX], 1
            RTS

; move cursor to next line if at end of line
:ROME8B3    SET X, ROWS_IN_LINE ;2
            SET A, HW_COLS-1
:ROME8B7    IFE [PNTR], A    ; at end of physical line #X
                JMP ROME8C2  ; move to next line.
            ADD A, HW_COLS
            SUB X, 1
            IFN X, 0
                JMP ROME8B7
            RTS
:ROME8C2    SET X, [TBLX]
            IFN [TBLX], HW_ROWS
                ADD [TBLX], 1
            RTS

; check for color change codes
:ROME8CB
            SET X, 0x0f
:ROME8CD    IFE A, [ROME8DA+X]
                JMP ROME8D6
            SUB X, 1
            IFA X, -1
                JMP ROME8CD
            RTS
:ROME8D6    AND [COLOR], 0x0F00
            SHL X, 12
            BOR [COLOR], X
            RTS

:ROME8DA ; color codes
    DAT 0x90, 0x05, 0x1c, 0x9f, 0x9c, 0x1E, 0x1F, 0x9E
    DAT 0x81, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b

; scroll screen
:ROME8EA    ; bypassed stack push of $AC-$AF.   
:ROME8F6    SET X, -1
            SUB [TBLX], 1
            SUB [LXSP], 1
            SUB [RAM02A5], 1  ; a temporary index
            ; Loop to the bottom of the screen and
            ; move each line upward, including its link
:ROME8FF    ADD X, 1
            JSR ROME9F0  ; set PNT line pointer to X
            IFG X, HW_ROWS-2  ; CPX #$18
                JMP ROME913   ; BCS $E913
            SET A, X
            ADD A, 1
            MUL A, HW_COLS
            ADD A, [HIBASE]
            SET [SCPNT], A
            JSR ROME9C8 ; move line up
            JMP ROME8FF
:ROME913    JSR ROME9FF ; clear a screen line
            SET X, 0
:ROME918    SET [LDTB1+X], [LDTB1+1+X]
            ADD X, 1
            IFl X, HW_ROWS-1
                JMP ROME918
            SET [LDTB1+HW_ROWS-1], DL_UNLINKED
:ROME92F    IFC [LDTB1], DL_UNLINKED ; top line was linked
                JMP ROME8F6   ; scroll another line
            ADD [TBLX], 1
            ADD [RAM02A5], 1
:ROME938    ; todo: Test for CTRL key
; ...       
               JMP ROME956
:ROME94B    SET X, 10000 ; how long to pause
:ROME94D    SET X, X; ; NOP
            SUB X, 1;
            IFN X, 0
                JMP ROME94D
:ROME954    SET [NDX], 0  ; clear keyboard buffer
:ROME956    SET X, [TBLX]
:ROME958    RTS
; insert blank line in screen
:ROME965
            SET X, [TBLX] ; current line
:ROME967    ADD X, 1
            SET A, [LDTB1+X]
            IFC A, DL_UNLINKED
                JMP ROME967
            SET [RAM02A5], X ; RAM02A5 is first unlinked line
                             ; below initial X value.
            IFE X, HW_ROWS-1
                JMP ROME981
            IFL X, HW_ROWS-1
                JMP ROME981
        
            JSR ROME8EA ; scroll the screen
            SET X, [RAM02A5]
            SUB X, 1
            SUB [TBLX], 1
            JMP ROME6DA ; Link line X with next line

:ROME981    
            SET X, HW_ROWS
:ROME98F    SUB X, 1
            JSR ROME9F0  ; set PNT line pointer to X
            IFL X, [RAM02A5]
                JMP ROME9A6
            IFE X, [RAM02A5]
                JMP ROME9A6
            ; get address of start of line
            SET A, [PNT]
            SUB A, HW_COLS
            SET [SCPNT], A
            JSR ROME9C8  ; Move line from SCPNT to PNT
            JMP ROME98F ; repeat with previous line

:ROME9A6    JSR ROME9FF ; Clear a screen line
:ROME9A9    SET X, HW_ROWS-2
:ROME9AB    IFL X, [RAM02A5]
                JMP ROME9BF
:ROME9B0    SET A, 0  ; no longer need to preserve addr
            IFB [LDTB1+X], DL_UNLINKED
                BOR A, DL_UNLINKED
:ROME9BA    SET [LDTB1+1+X], A
            SUB X, 1
            IFN X, 0
            JMP ROME9AB
:ROME9BF    SET X, [RAM02A5]
            JSR ROME6DA ; link line X with next line
            JMP ROME958 ; RTS

; move one screen line from [SCPNT] to [PNT]
; Instead of passing in a high byte in A,
; make sure the whole source address is in [SCPNT].
:ROME9C8
            SET Y, HW_COLS-1
            SET I, [SCPNT]
            ADD I, Y
            SET J, [PNT]
            SET A, J
            ADD J, Y
:ROME9D4
            STD [J], [I] 
            STD [J], [I] 
            IFG J, A
                JMP ROME9D4
            RTS

    
; set color/screen addresses
:ROME9E0    ; Unnecessary
            RTS

; fetch screen addresses
:ROME9F0    ;SET A, [ROMECF0+X]
            ;ADD A, [RAM0287]
            SET A, X
            MUL A, HW_COLS
            ADD A, [HIBASE]
            SET [PNT], A
            RTS

; clear one screen line
:ROME9FF
            JSR ROME9F0   ; set [PNT] line pointer to line X
            SET I, [PNT]
            SET J, HW_COLS-1
            ADD I, J
            SET A, 0x0020 
            BOR A, [COLOR]
:ROMEA07    STD [I], A
            STD [I], A
            IFA J, -1
                JMP ROMEA07
            RTS

; set cursor flash timing
; (and color memory addresses)
:ROMEA13
    SET [BLNCT], 2
    ;JSR ROMEA24

    ; put a char on the screen
; color in X
; character in A

:ROMEA1C
    AND A, 0xFF
    AND X, 0xFF00
    BOR A, X
    SET Y, [PNTR]
    ADD Y, [PNT]
    SET [Y], A
:ROMEA23    RTS

:ROMEA24 ; Unnecessary because the LEM1802
        ; display doesn't have separate color memory
        RTS

; input a character
; get a character

:CHRCOUNT DAT 0

:ROME716    SET PUSH, A
            AND A, 0xFF ; PETSCII is 8-bit
            SET [RAMD7], A
            SET PUSH, X
            SET PUSH, Y
            SET PUSH, I
            SET PUSH, J
            SET [CRSW], 0
            SET Y, [PNTR]
            IFB A, 0x0080 
                JMP ROME7D4
            ; Handle unshifted characters
:ROME72A    IFE A, CBM_RETURN  
                JMP ROME891  ; handle CR
            IFL A, 0x20
                JMP ROME745
            IFL A, 0x60
                JMP ROME73D
            AND A, 0xDF
            IFN A, 0
                JMP ROME73F
:ROME73D    AND A, 0x3F
:ROME73F    IFE A, CBM_QUOTE
                XOR [QTSW], 1
            JMP ROME693  ; print character
:ROME745    SET X, [INSRT]
            IFN X, 0
                JMP ROME697  ; print reverse
            IFN A, CBM_DELETE 
                JMP ROME77E
            IFN Y, 0
                JMP ROME759
            JSR ROME701 ; move cursor bak does two POPs
            SET I, [PNT]
            ADD I, Y
            JMP ROME773
:ROME759    JSR ROME8A1 ; move cursor to prev line if at start
    ; Move rest of line to the left with the cursor.
            SUB Y, 1
            ;JSR ROMEA24
            SET [PNTR], Y
            SET I, [PNT]
            SET J, [PNT]  ; J = end of line
            ADD J, [LNMX]
            ADD I, Y
:ROME762    ADD I, 1
            SET [I-1], [I]
            IFN I, J  ;END OF LINE
                JMP ROME762
:ROME773    SET J, 0x0020 ; space
            BOR J, [COLOR]
            SET [I], J 
            JMP ROME6A8
:ROME77E    IFN [QTSW], 0
                JMP ROME697  ; print reverse
:ROME785    IFE A, 0x0E  ; lowercase mode
                JSR TOLOWER
            IFE A, 0x12  ; RVS code
                JMP RVS_ON
            IFE A, CBM_HOME 
                JMP DOHOMEKEY
            IFN A, CBM_RIGHT 
                JMP ROME7AD
:ROME796        ; do crsr-right
            ADD Y, 1
            JSR ROME8B3 ; handle end-of-line condition
            SET [PNTR], Y
            SUB Y, 1
            IFL Y, [LNMX]
                JMP ROME6A8 ; return from print
            SUB [TBLX], 1
            JSR ROME87C ; move cursor to next line
            SET Y, 0
:ROME7A8    SET [PNTR], Y
            JMP ROME6A8 ; return from print
:ROME7AD    IFN A, CBM_DOWN 
                JMP ROME7CE
            ; perform cursor down
            ; first assume we're in a linked line
            ADD Y, HW_COLS
            ADD [TBLX], 1
            IFL Y, [LNMX]
                JMP ROME7A8
            IFE Y, [LNMX]
                JMP ROME7A8
            SUB [TBLX], 1
:ROME7C0    SUB Y, HW_COLS
            IFU Y, 0
                JMP ROME7C8
                SET [PNTR], Y
            IFN Y, 0
                JMP ROME7C0
:ROME7C8    JSR ROME87C ; move cursor to next line
            JMP ROME6A8 ; return from print
:ROME7CE    JSR ROME8CB
            JMP ROMEC44
:DOHOMEKEY  JSR ROME566
			JMP ROME6A8
            
; Put shifted chars to screen

:ROME7D4    AND A, 0x7F ; remove shift bit
            IFE A, 0x7F ; code for PI
                SET A, 0x5E
            IFG A, 0x1F ; printable
                JMP ROME691 ; add 64 and print
:ROME7E3    IFE A, CBM_RETURN ; shift return
                JMP ROME891 ; HANDLE CR
            IFN [QTSW], 0
                JMP ROME82D
            IFN A, CBM_DELETE ; insert
                JMP ROME829
            SET Y, [LNMX]
            SET A, [PNT]
            ADD A, Y   ; A contains end of space to be inserted
            SET A, [A]
:ROME7F6    AND A, 0xFF
            IFN A, CBM_SPACE
                JMP ROME7FE
            IFN Y, [PNTR]
                JMP ROME805 ; No need to insert a line
:ROME7FE    IFE Y, HW_COLS*ROWS_IN_LINE-1
                JMP ROME6A8 ; do nothing; can't expand further
:ROME802    JSR ROME965 ; Insert a line below the current line
:ROME805    SET PUSH, I
            SET PUSH, J
            SET I, [LNMX]
            STD J, I  ; decrement both 
            ADD J, [PNT] 
            ;JSR ROMEA24
:ROME80A    STD [J+1], [J]
            IFN I, [PNTR]
                JMP ROME80A
            SET [J+1], [J] ; do one more
            ; fill in space
            SET I, [COLOR]
            AND I, 0xFF00
            BOR I, 0x0020
            SET [J], I ; TODO: Proper color
            SET J, POP
            SET I, POP
            ADD [INSRT], 1
            JMP ROME6A8
:ROME829    IFE [INSRT], 0
                JMP ROME832
:ROME82D    BOR A, 0x40  ; shift character
            JMP ROME697  ; and print reverse
:ROME832    IFN A, CBM_DOWN ; cursor up
                JMP ROME84C
            SET X, [TBLX]
            IFE X, 0
                JMP ROME6A8 ; Do nothing, return.
            SUB [TBLX], 1
            SET A, [PNTR]
            SUB A, HW_COLS
            IFU A, 0
                JMP ROME847
            SET [PNTR], A
            IFA A, -1 ; BPL
                JMP ROME6A8
:ROME847    JSR ROME56C ; get address
            JMP ROME6A8 ; retunr from print

:ROME84C    IFE A, 0x0E ; Uppercase mode
                JSR TOUPPER
            IFE A, 0x12 ; reverse off
                SET [RVS], 0
            IFN A, CBM_RIGHT ; cursor left
                JMP ROME86A
            ; do crsr left
            IFE Y, 0
                JMP ROME864
            JSR ROME8A1 ; handle edge of screen?
            SUB Y, 1
            SET [PNTR], Y
            JMP ROME6A8
:ROME864    JSR ROME701
            JMP ROME6A8
:ROME86A    IFN A, CBM_HOME ; clr code
                JMP ROME874
            JSR ROME544
            JMP ROME6A8
:ROME874    BOR A, 0x80 ; restore high bit
            JSR ROME8CB ; check for color change codes
            JMP ROMEC4F
            

:MAKE_CBM_FONT
    SET A, 4 ; DUMP FONT
    SET B, VISFONT  ; visible font area
    HWI [MONITOR]
    SET A, 3 ; border color
    SET B, 14 ; light blue
    HWI [MONITOR]
    SET A, 2 ; MAKE VISIBLE CUSTOM PALETTE
    SET B, CBM_PALETTE
    HWI [MONITOR]
; Copy XOR map that changes uppercase to lowercase
    SET I, VISFONT+130 ; Location of letter A
    SET J, FONTXOR1
:FONTLOOP0
    SET A, [I]
    XOR A, [I+64]
    STI [J], A
    IFL J, FONTXOR1+52
       SET PC, FONTLOOP0
; copy characters 64-95 to 0-31,
; and characters 96-127.
    SET I, VISFONT
    SET J, 0
:FONTLOOP1
    SET [I], [I+128]   ; Copy lowercase to top 32
    SET [I+128], [J+UPCGFX]   ; Copy lowercase to 64-range
    STI [I+192], [J+COMGFX]  ; Copy C= graphics into 
    IFL I, VISFONT+64
        SET PC, FONTLOOP1
; Copy XOR map that changes uppercase to graphics
    SET I, VISFONT+2 ; Location of letter A
    SET J, FONTXOR2
:FONTLOOP2
    SET A, [I]
    XOR A, [I+128]
    STI [J], A
    IFL J, FONTXOR2+52
       SET PC, FONTLOOP2
    ; make checkmark xor
    XOR [CHECKMARK_XOR], [CHECKMARK_GFX]
    XOR [CHECKMARK_XOR+1], [CHECKMARK_GFX+1]
    ; start in lowercase?
    IFE STARTLOWER, 1
        JSR TOGGLEFONT
    ; i hate the crossbar zero in a 4x8 font
    ; this looks much better
    SET [VISFONT+96], 0x3E63
    ; c64-like uparrow and leftarrow
:FONTARROWLOOP
	SET J, UPLEFT
	SET I, VISFONT+60
	STI [I], [J]
	STI [I], [J]
	STI [I], [J]
	STI [I], [J]
	; make font visible
    SET A, 1 ; MAKE VISIBLE CUSTOM FONT
    SET B, VISFONT  ; visible font area
    HWI [MONITOR]
    RTS

:TOGGLEFONT
; toggle the character set onse
; there's probably an optimal way to do this
; to reduce risk of fire.
    SET I, 0
:TOGGLELOOP
    XOR [I+VISFONT+2], [I+FONTXOR1]
    XOR [I+VISFONT+130], [I+FONTXOR2]
    ADD I, 1
    IFL I, 52
        JMP TOGGLELOOP
    ; toggle box-drawing and checkmark in CBM area
    XOR [VISFONT+244], [CHECKMARK_XOR]
    XOR [VISFONT+245], [CHECKMARK_XOR+1]
    RTS

:TOUPPER
    SET I, 0
    IFN [VISFONT+130], 0x587F
        JMP TOGGLELOOP
    RTS

:TOLOWER
    SET I, 0
    IFE [VISFONT+130], 0x587F
        JMP TOGGLELOOP
    RTS

:VISFONT    
    .FILL BLANK, 256
:COMGFX
    DAT 0, 0  ; shift-space
    DAT 0xFFFF, 0x00 ; left block
    DAT 0xF0F0, 0xF0F0 ; bottom block
    dat 0x0101, 0x0101 ; top pixel across
    DAT 0x8080, 0x8080 ; bottom pixel across
    DAT 0xFF00, 0x00 ; left 25%
    DAT 0x33CC, 0x33CC ; checkerboard
    DAT 0x0000, 0x00FF ; right 25%
    DAT 0x30C0, 0x30C0 ; bottom checkerboard
    DAT 0xFF3F, 0x0F03 ; top left half diagonal
    DAT 0x0000, 0x00FF ; right 25%
    DAT 0x00FF, 0x1818 ; box drawing: up down right
    DAT 0x0000, 0xF0F0 ; bottom right quadrant
    DAT 0x001F, 0x1818 ; box drawing: up right
    DAT 0x1818, 0xF800 ; box drawing: down left
    DAT 0xC0C0, 0xC0C0
    DAT 0x00F8, 0x1818
    DAT 0x181F, 0x1818
    DAT 0x18F8, 0x1818
    DAT 0x18FF, 0x0000
    DAT 0xFF00, 0x00 ; left 25%
    DAT 0xFF00, 0x00 ; left 25%
    DAT 0x0000, 0x00FF ; right 25%
    DAT 0x0303, 0x0303 ; top 25%
    DAT 0x0707, 0x0707 ; top 3/8
    DAT 0xE0E0, 0xE0E0 ; bottom 3/8
:CHECKMARK_GFX
    DAT 0xC0C0, 0xC0FF ; box drawing/checkmark
    DAT 0xF0F0, 0x0000
    DAT 0x0000, 0x0F0F
    DAT 0x181F, 0x0000
    DAT 0x0F0F, 0x0000
    DAT 0x0F0F, 0xF0F0
; Uppercase graphics
:UPCGFX
    DAT 0x1818, 0x1818
    DAT 0x587F, 0x5800
    DAT 0x00FF, 0 ; Petscii vertical bar
    DAT 0x1818, 0x1818 ; Petscii horiz bar
    DAT 0x0C0C, 0x0C0C ;
    DAT 0x0606, 0x0606 ; E
    DAT 0x3030, 0x3030 ;F
    DAT 0x00FF, 0x0000 ;G
    DAT 0x0000, 0xFF00 ;H
    DAT 0x18F0, 0x0000 ;I
    DAT 0x000F, 0x1818 ;J
    DAT 0x180F, 0x0000 ;K
    DAT 0xFFC0, 0xC0C0 ;L
    DAT 0x030C, 0x30C0 ;M
    DAT 0xC030, 0x0C03 ;N
    DAT 0xFF03, 0x0303 ;O
    DAT 0x0303, 0x03FF ;P
    DAT 0x3C7E, 0x3C00 ;Q
    DAT 0x6060, 0x6060 ;R
    DAT 0x1F7E, 0x1F00 ;S
    DAT 0xFF00, 0 ;T
    DAT 0x00F0, 0x1818 ;U
    DAT 0xC33C, 0x3CC3 ;V
    DAT 0x3C66, 0x3C00 ;Empty circle
    DAT 0x4C73, 0x4C00 ;Clubs
    DAT 0, 0xFF00      ;Verticle bar at 5/8
    DAT 0x1C7F, 0x1C00 ;Diamond
    DAT 0x18FF, 0x1818; cross
    DAT 0x33CC, 0 ; Left 50%
    DAT 0x00FF, 0 ; Petscii vertical bar
    DAT 0x7C04, 0x7C00 ; pi
    DAT 0x0003, 0x0F3F ; Upper right triangle
:UPLEFT  ; arrow graphics
    DAT 0x0CFE, 0x0C00
    DAT 0x187E, 0x1818

; this will be converted to an XOR mask at runtime.
:CHECKMARK_XOR
    DAT 0x7030, 0x0C03  
; XOR masks to toggle uppercase-lowercase
:FONTXOR1
    .FILL BLANK, 52
; XOR masks to toggle graphics-uppercase 
:FONTXOR2
    .FILL BLANK, 52

:CBM_PALETTE
    DAT 0x000, 0xfff, 0xf00, 0x0ff
    DAT 0xf0f, 0x0f0, 0x00f, 0xff0
    DAT 0xf80, 0x840, 0xf99, 0x444
    DAT 0x888, 0x9f9, 0x99f, 0xccc


; scroll pointer
:SCPNT  DAT 0
:RAMB2  DAT 0
:RAMC1  DAT 0

; keyboard memory
;
; Keyboard Decode Table
:KEYTAB 
:RAMF5 DAT 0

; another floating point conversion thingy
:BASZPT 
:RAMFF DAT 0

;------

; This block of 256 bytes had the same function as the 6502 stack.
; Notable differences include:
;    originally, GOSUB pushed 5 bytes on the stack; now it pushes 3.
:STACK         
              .FILL BLANK, 256
:STACKBASEND
                .FILL BLANK, 6
:STACKEND


:RAM0277    ;KEYBOARD BUFFER
:KEYD
    .FILL 32, KEYBOARD_BUFFER_SIZE

:RAM01FB  DAT 0
:RAM01FC  DAT 0
:RAM01FD  DAT 0
:RAM01FE  DAT 0
:RAM01FF  DAT 0
:RAM0200  ; String buffer?
    .FILL 0, BASIC_BUFFER_LENGTH
:RAM0281 
:MEMSTR   ; Start of memory, only used once
        DAT BASICMEM
:RAM0283  ; End of memory found by RAMTAS
        DAT BASICMEMEND
:RAM0285 ; ???
        DAT 0

:RAM0289
:XMAS   DAT 10
:RAM0291
:MODE       DAT 0

; BASIC Indirect Vector Table
; if you guys want to port the DOS wedge go ahead
:RAM0300
:IERROR     DAT DEF_ERROR
:RAM0302
:IMAIN      DAT DEF_MAIN
:RAM0304
:ICRNCH     DAT DEF_CRUNCH    ; crunch tokens
:RAM0306
:IQPLOP     DAT DEF_QPLOP    ; print tokens
:RAM0308
:IGONE      DAT GONE        ; execute statement?
:RAM030A
:IEVAL      DAT DEF_EVAL
:RAM030C    DAT 0
; IRQ
:RAM0314    DAT ROMEA31
:RAM0316    DAT 0
:IIOBASE
:RAM0318    DAT ROME500
:IOPEN
:RAM031A    
            DAT DEF_OPEN
:ICLOSE
:RAM031C    DAT DEF_CLOSE
:ICHKIN
:RAM031E    DAT DEF_CHKIN
:ICHKOUT
:RAM0320    DAT DEF_CHKOUT
:ISOMETHING
:RAM0322    DAT ROMF333
:ICHRIN
:RAM0324    DAT DEF_CHRIN
:ICHROUT
:RAM0326    DAT DEF_CHROUT
:ISTOP
:RAM0328    DAT DEF_STOP
:IGETIN 
:RAM032A    DAT DEF_GETIN
:ICLALL  
:RAM032C    DAT DEF_CLALL
:RAM033C    DAT 0

; TODO: use preprocessor to hide all the debugging code
; when HW_ROWS >= 12.

; Error handler for IO calls
:ROME0F9    IFN A, 0xF0
                JMP ROME104
            ; 0xF0 is a special error?
            SET [MEMSIZ], X
            JMP ROMA663
:ROME104    IFE X, 0
                SET X, 0x1E   ; BREAK
            JMP ERROR

; CHROUT/CHRIN plus error checking for BASIC
; (treats EX as error flag, X as error number)
:ROME10C    JSR [ICHROUT]
            IFN EX, 0 ; carry bit set
                JMP ROME0F9
            RTS
:ROME112    JSR [ICHRIN]
            IFG EX, 0
                JMP ROME0F9
            RTS
:ROME118    JSR ROME4AD
            IFG C, 0
                JMP ROME0F9
            RTS
:ROME11E    JSR CHKIN
            IFG C, 0
                JMP ROME0F9
            RTS
:ROME124    JSR GETIN
            IFG C, 0
                JMP ROME0F9
            RTS
            
:ROME4AD
            SET PUSH, A
            JSR ROMFFC9
            SET  X, A
            SET A, POP
            IFE C, 0
                RTS
            SET A, X
            RTS

; special debugging code that shows
; where all the line links are
:LINELINKS
		SET PUSH, A
		SET PUSH, B
		SET PUSH, C
		SET A, 0
		SET B, SCREENMEM+HW_COLS-1
:LINELINKSLOOP
        SET C, 0x0500
		IFE [LDTB1+A], DL_UNLINKED
		    SET C, 0x0600
        AND [B], 0xF0FF
        BOR [B], C
        ADD B, HW_COLS
        ADD A, 1
        IFL A, HW_ROWS
            JMP LINELINKSLOOP
    	SET C, POP
    	SET B, POP
    	SET A, POP
    	RTS

; *****************************************************
;    Normal IRQ Interrupt 
;
; This runs 60 times per second, and has the following
; duties:
;   * Update system clock
;   * Blink the cursor if it is visible
;   * Scan the keyboard, add new characters to the
;     keyboard buffer.
; *****************************************************
:IRQ_HANDLER
:ROMEA31    
            ; some debugging for last line link bugs
            ;JSR LINELINKS

            ;JSR ROMFFEA ; do clock
            IFN [BLNSW], 0
                JMP ROMEA61
            ; FLASH CURSOR
            SUB [BLNCT], 1
            IFN [BLNCT], 0
                JMP ROMEA61
            SET [BLNCT], BLINK_FRAMES
            XOR [BLNON], 1  ; was last blink on/off?
            SET A, [PNTR] ; CURSOR POSITION
            ADD A, [PNT]
            IFE [BLNON], 0  ; last blink was off
                JMP ROMEA5C
            SET [GDBLN], [A] ; store chr under cursor
            ;JSR ROMEA24
            SET Y, [COLOR]
            SET X, Y
            AND Y, 0x0F00
            SHL Y, 4
            AND X, 0xF000
            SHR X, 4
            BOR X, Y
            AND [A], 0xFF   ; blink on-phase
            BOR [A], X
            IFE A, -1 ; SKIP
:ROMEA5C    SET [A], [GDBLN] ; blink off-phase
:ROMEA61    ; check cassette?
:ROMEA7B    JSR ROMEA87 ; scan keyboard
            SET Y, POP
            SET X, POP
            SET EX, POP
            RFI -1

; I appropriated this to display another
; chunk of memory in the status bar.
:DISPLAY_LINK_TABLE
        SET PUSH, I
        SET PUSH, J
        SET I, LDTB1
        SET J, DEBUGLNK-1
:LINKLOOP
        STI X, [I]
        SET [J], 0x192E
        IFC X, DL_UNLINKED
            SET [J], 0x1921
        IFL I, LDTB1+HW_ROWS+3
        JMP LINKLOOP
        SET J, POP
        SET I, POP
        RTS

:HEXTHING
   .FILL 48, 10
   .FILL -9, 6
:DISPLAY_KEY_DEBUG
        ; debugging code to display some registers every frame
        SET Y, [COUNT]  ; 
        SET X, DEBUGKEY+9
        SET PUSH, B
:DBGLOOP
    ; display Y register in hex in debugging line
        SET B, Y
        AND B, 0x0F
        ADD B, [HEXTHING+B]
        SET [X], B
        BOR [X], 0xF000
        DIV Y, 0x10
        SUB X, 1
        IFG X, DEBUGKEY+5
           JMP DBGLOOP
        ; another one
        SUB X, 1
        SET Y, [VARTAB]
        ;SET [Y], 0x41
:DBGLOOP2
    ; display Y register in hex in debugging line
        SET B, Y
        AND B, 0x0F
        ADD B, [HEXTHING+B]
        SET [X], B
        BOR [X], 0xF000
        DIV Y, 0x10
        SUB X, 1
        IFG X, DEBUGKEY+0
           JMP DBGLOOP2
        SET B, POP

:ROMEAE0 
;Decode the Keystroke and Place its ASCII Value in the Keyboard Buffer


:ROMEB48    ;Set up proper keyboard decode table
            RTS
; load/run for RUN key

:ROMEC44    IFN A, 0x0E ; Lowercase code
                JMP ROMEC4F
            ; TODO: FINISH
:ROMEC4F    IFN A, 0x8E ; Uppercase code
                JMP ROMEC5E
            ; TODO: FINISH
            
; SHIFT-C= KEY CHECK
:ROMEC5E
    ; TODO: FINISH
            JMP ROME6A8
       
            
; KERNAL STUBS
:ROME37B    RTS

:DEF_IOBASE
:ROME500    RTS


; In CBM BASIC, this was copied to 0073.
; In DCPU-16, I'm just defining this address
; because there's a BASIC variable fetch routine
; that inexplicably used this address as some
; kind of comparison.
:INITAT
:ROME3A2    dat 0x9000


:ROMF017    ; RS232-related
            RTS
:ROMF12B    ; print kernal message indexed by Y
            ; send complete address in Y
            IFC [MSGFLG], 0x80 
                JMP ROMF13C
:ROMF12F    SET A, [Y]
            SET PUSH, A
            JSR CHROUT
            ADD Y, 1
            SET A, POP
            IFL A, 0x80
                JMP ROMF12F
:ROMF13C    SET C, 0 ; no error
            RTS
:ROMF1FC    RTS
:DEF_UDTIM
:ROMF69B    RTS
:DEF_RDTIM
:ROMF6DD    RTS
:DEF_SETTIM
:ROMF6E4    RTS
:CINT
:ROMFF5B    RTS

;
; KERNAL IO routines for use with DCPU-BASIC
;
; I'm trying to make this one the most modular.
;
;
; RAM definitions
;
; Filename and length
:RAMB7
:FNLEN  DAT 0
:RAMBB
:FNADR  DAT 0
:RAM93
:VERCK  DAT 0
:RAM97
:XSAV   DAT 0
:RAM99
:DFLTN  DAT 0
:RAM9A
:DFLTO  DAT 3

:RAM90
:STATUS DAT 0
:RAM9D
:MSGFLG DAT 0
:RAMAC
:SAL    DAT 0
:RAMAE
:EAL    DAT 0



; common stub routines
:IO_RT_ERROR
    SET C, 1
:IO_RTS
    SET PC, POP

:DEVICE_TABLE
; format: device spec, hardware number, current claimed file
    DAT KEYBOARD_DEVICE, 0, 0   ; 0
    DAT NULL_DEVICE    , 0, 0   ; tape, really?
    DAT MODEM_DEVICE   , 0, 0   ; network?
    DAT SCREEN_DEVICE  , 0, 0   ; ?
    DAT PRINTER_DEVICE , 0, 0
    DAT PRINTER_DEVICE , 0, 0
    DAT NULL_DEVICE
    DAT NULL_DEVICE
    DAT DISK_DEVICE
    DAT DISK_DEVICE
;
; DEVICE JUMP TABLES
;
; format: open close read write flush

; requires keyboard.dasm16
:KEYBOARD_DEVICE

; requires screen.dasm16
:SCREEN_DEVICE

; requires ramdisk.dasm16
:DISK_DEVICE

; unimplemented devices
:NULL_DEVICE
:PRINTER_DEVICE
:MODEM_DEVICE
DAT IO_RTS, IO_RTS, IO_RTS, IO_RTS, IO_RTS



:DEF_GETIN
:ROMF13E    IFN [DFLTN], 0
               JMP ROMF14A
            IFE [NDX], 0    ; if keyboard buffer is blank
               JMP ROMF155 ; return 0
            ; SEI
            JMP ROME5B4

:ROMF14A     IFN [DFLTN], 2
               JMP ROMF166
             ; insert serial handler here?
             RTS
:ROMF155    ; return blank result for getin
            SET C, 0
            SET A, 0
            SET Z, 1
            RTS

; input a character
; if keyboard: get line, and then return
; characters one at a time

:DEF_CHRIN
:ROMF157   IFN [DFLTN], 0
             JMP ROMF166
           ; record current position of cursor as
           ; start of input on the screen.
           SET [LXSP+1], [PNTR] ; column
           SET [LXSP], [TBLX]   ; row
           JMP ROME632

:ROMF166   IFN [DFLTN], 3
               JMP ROMF173
           SET [CRSW], 3
           SET [INDX], [LNMX]
           JMP ROME632 ; input a character from screen

:ROMF173   IFG [DFLTN], 3 ; C64 serial bus device
               JMP ROMF1AD
           ; ... omitted cassette and RS232 code
           RTS

:ROMF1AD   ;IFE [RAM90], 0
           ;    JMP ROMEE13 ; Read byte from serial bus
           SET A, CBM_RETURN ; CR?
       SET EX, 0
       RTS

; output a character
; stub: always output to screen
:DEF_CHROUT
:ROMF1CA   IFE [DFLTO], 3
             JMP ROME716
       ;IFL [DFLTO], 3
       ;  JMP ROMEDDD  ; Write byte to serial bus
       ; ...
           RTS

:ROMF208   JSR ROMF017 ; rs232-related
:ROMF20B   JMP ROMF1FC ; also stubbed for now

; set input device
:DEF_CHKIN
:ROMF20E    RTS

; set output device
:DEF_CHKOUT
:ROMF250    RTS

; close a file
:DEF_CLOSE
:ROMF291    RTS

; close all files
:DEF_CLALL
:ROMF32F    RTS

; restore I/O to default devices
:ROMF333    RTS

; open a file
:DEF_OPEN
:ROMF34A    RTS
:ROMF5D2    SET Y, MSG_LOADING
            IFN [RAM93], 0
               SET Y, MSG_VERIFYING
            JMP ROMF12B

:DEF_LOAD
:ROMF49E    RTS

:DEF_SAVE
; i forgot the address
        RTS


; DCPU hardware

:KEYBOARD dat 0
:MONITOR dat 0
:CLOCK DAT 0

:IOINIT
    hwn i
:map_hardware
    sub I, 1
    hwq I
    ife B, 0x7349
        ife A, 0xF615
            set [MONITOR], I
    ife B, 0x30CF
        ife A, 0x7406
            set [KEYBOARD], I
    ife B, 0x12d0
        Ife A, 0xb402
            set [CLOCK], I
    ife A, 0x12d0
        Ife B, 0xb402
            set [CLOCK], I
    ifn I, 0
        set pc, map_hardware

; Next, we set the monitor's screen to  ;
; start at the memory location
:initialize_monitor
    set A, 0  ; set screen memory
    set B, SCREENMEM
    hwi [MONITOR]

    JSR MAKE_CBM_FONT
    set A, 3  ; set border
    set B, 0xE  ; light blue
    hwi [MONITOR]

:initialize_keyboard
    SET A, 3
    SET B, KEYINT
    HWI [KEYBOARD]

    RTS

; Here are some subroutines that can probably be
; replaced with a single DCPU-16 instruction
; where appropriate.

; move save/load address into $AC/$AD

;:ROMFB8E    SET [SAL], [RAMC1]
;            RTS

; compare $AC/$AD with $AE/$AF

;:ROMFCD1    SET C, 0
;            IFG [SAL], [EAL]
;               SET C, 1
;            RTS


; increment $AC/$AD

;:ROMFCDB    ADD [SAL], 1
;            RTS

:SETNAM
:ROMFFBD
:ROMFDF9    SET [FNLEN], A
            SET [FNADR], X
            RTS
; get IO status?
:ROMFE07
        SET A, 0
        RTS

; control kernal messages
:SETMSG
:ROMFF90
:ROMFE18    SET [MSGFLG], A
            SET A, [STATUS]
; add A bits to ST
            BOR [STATUS], A
            RTS


; save ram to a device
; X is an address, A is a pointer.

:ROMF5DD   SET [EAL], X
           SET [RAMC1], [A]
           ;JMP [RAM0332] ;normally F5ED

; standard save ram entry
:ROMF5ED  RTS

; handle messages for loading
:ROMF5AF    IFC [MSGFLG], 0x80
                RTS
            SET Y, MSG_SEARCHING
                JSR ROMF12F
            SET A, [FNLEN]
            IFE A, 0
                RTS
            SET Y, 17
            JSR ROMF12F
            SET Y, [FNLEN]
            IFE Y, 0
                RTS
:ROMF5C7    SET A, [FNADR+Y]
            JSR CHROUT
            ADD Y, 1
            IFN Y, [FNLEN]
                JMP ROMF5C7
            RTS

; do load/verify message

:MSG_SEARCHING
            .DAT 13, "SEARCHIN", 0xC7
:MSG_LOADING
:ROMF106    .DAT 13, "LOADIN", 0xC7
:MSG_SAVING
:ROMF10E    .DAT 13, "SAVIN", 0xC7
:MSG_VERIFYING
:ROMF116    .DAT 13, "VERIFYIN", 0xC7

; close serial bus device
;:ROMF642  RTS


; check for STOP key (probably ESC)
; return C=1 if STOP key pressed.
:DEF_STOP
:ROMF6ED    SET Z, 0
                SET C, 0
            IFN [RAM91], 0x7F
                RTS
            JSR ROMFFCC
          ; clear keyboard buffer
            SET [RAMC6], 0
           ; clear stop flag?
            SET [RAM91], 0
            SET C, 1
            SET Z, 1
            RTS

; increment real time clock
;:ROMF89B  RTS

; RESET routine  (SYS 64738)

:ROMFCE2       SET SP, STACKEND-1
               ; omitted cartridge code at FCE7 and FD02
; initialize display, keyboard and clock
:ROMFCF2      JSR IOINIT 
:ROMFCF5      JSR RAMTAS 
              JSR RESTOR 
              JSR CINT   
              IAQ 0 ;CLI
              JMP_IND ROMA000  ; START BASIC              

; restore I/O vectors
; this isn't necessary because the I/O vectors are assembled in
; but this part should be ported if anyone wants to do any 
; hardcore IO-level kernal porting.
:RESTOR
:ROMFD15    SET X, ROMFD30
            SET C, 0
            ; TODO: loop through all vectors
            SET [RAM0314], [ROMFD30]
            ;  Create a clock interrupt
            :add_clock
            set a, 0   ; activate clock interrupt
            set b, 1   ; frequency - every frame
            hwi [CLOCK]    
            set a, 2  ; set interrupt mesage
            set b, [clock_interrupt_message]
            hwi [CLOCK]  ; set the interrupt message
            ias MASTER_INT   ; set the interrupt handler

            RTS
:ROMFD30    DAT ROMEA31 ; IRQ
            DAT ROMFE66 ; BRK
            DAT ROMFE47 ; NMI

:MASTER_INT
:ROMFF48 ; In the original 6502 one,
         ; this routine pushed A, X, and Y before
     ; calling one of the two interrupts.
         ; CLOCKINT uses mostly A/X/Y.
     ; KEYINT uses mostly A/B/C.
     ; the BRK routine at FE6F isn't known
    IFE A, [clock_interrupt_message]
        JMP CLOCKINT
    IFE A, KEYINT
        JMP KEYINT
        ;ignore all others
    RFI 10

:CLOCKINT
    SET PUSH, EX
    SET PUSH, X
    SET PUSH, Y
    JMP_IND RAM0314
:clock_interrupt_message
        DAT ROMEA31


; make a custom vector
; i should probably port this
:VECTOR
:ROMFD1A    RTS

; initalise memory pointers
;
:RAMTAS
:ROMFD50
; the original 6502 kernal cleared pages 0, 2, and 3.
; but there's no RAM-ROM distinction so we don't have
; to do this for the DCPU port.
; also skipping the RAM test.
            SET [RAMB2], RAM033C   ; 828...cassette buffer?
            ;JSR ROMFE2D
            SET [RAM0281], BASICMEM
            SET [HIBASE], SCREENMEM
:ROMFD9A    RTS

; read/set top of memory
:MEMTOP
:ROMFF99
:ROMFE25   IFN C, 0 ; write if carry bit set
           SET X, [RAM0283]
           SET [RAM0283], X
           RTS

; read/set bottom of memory
:MEMBOT
:ROMFF9C
:ROMFE34   IFN C, 0 ; write if carry bit set
           SET X, [MEMSTR]
           SET [MEMSTR], X  
           RTS

; NMI entry stub
:ROMFE43   ; SEI
           JMP_IND RAM0318

; Standard NMI routine stub
:ROMFE47   ;???
           RFI 9001

; BRK routine

:ROMFE66     JSR RESTOR
:ROMFE69     JSR IOINIT
:ROMFE6C     JSR ROME518 ; initialize screen and keyboard
:ROMFE6F     JMP_IND ROMA002

; skipping a lot of file i/o-related kernal for now

:ROMFFB7    JMP ROMFE07
:OPEN
:ROMFFC0  JMP_IND RAM031A   ; (F34A) open a file
:CLOSE
:ROMFFC3  JMP_IND RAM031C   ; (F291) close a file
:CHKIN
:ROMFFC6  JMP_IND RAM031E   ; (F20E) set input device
:CHKOUT
:ROMFFC9  JMP_IND RAM0320   ; (F250) set output device
:CLRCHN
:ROMFFCC  JMP_IND RAM0322   ; (F333) restore I/O devices to default
:CHRIN
:ROMFFCF  JMP_IND ICHRIN   ; (F157) input char on current device
:CHROUT
:ROMFFD2  JMP_IND ICHROUT   ; (F1CA) output char on current device
:LOAD
:ROMFFD5  JMP DEF_LOAD      ; load RAM from device
:SAVE
:ROMFFD8  JMP DEF_SAVE      ; save RAM to device
:SETTIM
:ROMFFDB  JMP DEF_SETTIM      ; set real time clock
:RDTIM
:ROMFFDE  JMP ROMF6DD      ; read real time clock
:STOP
:ROMFFE1  JMP_IND ISTOP    ; (F6ED) check stop key
:GETIN
:ROMFFE4  JMP_IND IGETIN    ; (F13E) get a character
:CLALL
:ROMFFE7  JMP_IND ICLALL    ; (F32F) close all channels and files
:UDTIM
:ROMFFEA  JMP DEF_UDTIM   ; increment real time clock
:SCREEN
:ROMFFED  JMP DEF_SCREEN  ; read organisation of screen into XY
:PLOT
:ROMFFF0  JMP DEF_PLOT   ; read/set XY cursor position
:IOBASE
:ROMFFF3    JMP DEF_IOBASE  ; read base address of I/O devices
    
:ROMFFFA    DAT ROMFE43   ; NMI vector
:ROMFFFC  DAT ROMFCE2    ; RESET vector
:ROMFFFE  DAT ROMFF48     ; BRK vector
	    
:VARTABCRASH
    SET A, [VARTAB]
    SET B, [STREND]
    
:CRASH DAT 0x3000

:BASICMEM     
        .FILL 0, 10


